/*
 * This file is protected by Copyright. Please refer to the COPYRIGHT file
 * distributed with this source distribution.
 *
 * This file is part of REDHAWK VITA49Libraries.
 *
 * REDHAWK VITA49Libraries is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * REDHAWK VITA49Libraries is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
 * for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see http://www.gnu.org/licenses/.
 */
//
//  THIS FILE IS AUTO-GENERATED, DO NOT MODIFY
//
package nxm.vrt.lib;

import nxm.vrt.lib.VRTPacket.DataItemFormat;
import nxm.vrt.lib.VRTPacket.PayloadFormat;

import static java.lang.Double.doubleToRawLongBits;
import static java.lang.Double.longBitsToDouble;
import static java.lang.Float.floatToRawIntBits;
import static java.lang.Float.intBitsToFloat;
import static nxm.vrt.lib.VRTMath.*;

/** <b>Internal Use Only:</b> Pack/unpack methods used by {@link BasicDataPacket}. <br>
 *  <br>
 *  <h2>Usage Notes</h2>
 *  <ul>
 *    <li>If the data type of the array given does not match the PayloadFormat,
 *        the handling of any values outside of the mutual range limits is
 *        undefined. <i>(For example inserting the value 1024 from an Int32
 *        array into a PayloadFormat of Int8.)</i></li>
 *    <li>If the data type of the array given does not match the PayloadFormat,
 *        the handling of any values outside of the mutual precision limits
 *        will result in a loss of precision. (For example inserting the value
 *        3.14 from an Float32 array into a PayloadFormat of Int8 will result in
 *        the value 3 being set.)</li>
 *    <li>The handling of NaN, +Inf, and -Inf when converting from a floating-point
 *        type to an integer type is undefined.</li>
 *    <li>All floating-point NaN values are considered equal any NaN may be
 *        converted to any other NaN (i.e. "signaling NaN values" are not
 *        preserved).</li>
 *    <li>All floating-point 0.0 values (i.e. -0.0 and +0.0) are considered equal
 *        and any 0.0 may be converted to any other 0.0 (i.e. the sign bit on
 *        a 0.0 is not preserved).</li>
 *  </ul>
 *  <h2>Performance Characteristics</h2>
 *  Great effort has been made to optimize the most commonly used pack/unpack
 *  conversions. The table below shows the relative speed at which a given
 *  PayloadFormat can be packed/unpacked from a buffer.
 *  <pre>
 *       Speed   | Item Packing | Data Item |  Event   | Channel  | Efficient | Notes |
 *        [0]    |  Field Size  | Size [1]  | Tag Size | Tag Size |   Mode    |       |
 *    -----------+--------------+-----------+----------+----------+-----------+-------+
 *         A+    |       8      |     8     |    0     |     0    | Link/Proc |       |
 *     (Fastest) |              |           |          |          |           |       |
 *    -----------+--------------+-----------+----------+----------+-----------+-------+
 *         A     |       1      |     1     |    0     |     0    | Link/Proc |  [2]  |
 *               |       4      |     4     |    0     |     0    | Link/Proc |  [2]  |
 *               |      12      |    12     |    0     |     0    | Link/Proc |  [2]  |
 *               |      16      |    16     |    0     |     0    | Link/Proc |       |
 *               |      24      |    24     |    0     |     0    | Link/Proc |       |
 *               |      32      |    32     |    0     |     0    | Link/Proc |       |
 *               |      64      |    64     |    0     |     0    | Link/Proc |       |
 *               |      32      |   float   |    0     |     0    | Link/Proc |       |
 *               |      64      |   double  |    0     |     0    | Link/Proc |       |
 *    -----------+--------------+-----------+----------+----------+-----------+-------+
 *         A-    |       8      |  1 to  7  |    -     |     -    | Link/Proc |  [3]  |
 *               |      16      |  1 to 15  |    -     |     -    | Link/Proc |  [3]  |
 *               |      24      |  1 to 23  |    -     |     -    | Link/Proc |  [3]  |
 *               |      32      |  1 to 31  |    -     |     -    | Link/Proc |  [3]  |
 *               |      64      |  1 to 63  |    -     |     -    | Link/Proc |  [3]  |
 *               |   17 to 63   |  1 to 63  |    -     |     -    |    Proc   |       |
 *    -----------+--------------+-----------+----------+----------+-----------+-------+
 *         B     |      32      |  1 to 31  |  0 to 7  |  0 to 15 | Link/Proc |       |
 *               |      64      |  1 to 63  |  0 to 7  |  0 to 15 | Link/Proc |       |
 *               |      64      |   float   |  0 to 7  |  0 to 15 | Link/Proc |       |
 *               |   17 to 63   |  1 to 63  |  0 to 7  |  0 to 15 |    Proc   |       |
 *               |   33 to 63   |   float   |  0 to 7  |  0 to 15 |    Proc   |       |
 *    -----------+--------------+-----------+----------+----------+-----------+-------+
 *         D+    |    1 to 15   |  1 to 15  |    -     |     -    | Link/Proc | [3,4] |
 *               |   17 to 63   |  1 to 63  |    -     |     -    |    Link   |  [3]  |
 *               |   33 to 63   |   float   |    -     |     -    |    Link   |  [3]  |
 *    -----------+--------------+-----------+----------+----------+-----------+-------+
 *         D     |    1 to 15   |  1 to 15  |  0 to 7  |  0 to 15 | Link/Proc |  [4]  |
 *     (Slowest) |   17 to 63   |  1 to 63  |  0 to 7  |  0 to 15 |    Link   |       |
 *               |   33 to 63   |   float   |  0 to 7  |  0 to 15 |    Link   |       |
 *    -----------+--------------+-----------+----------+----------+-----------+-------+
 *
 *    Notes:
 *      [0] The "speed" rating is an arbitrary "grade" indicating how fast the accessing
 *          of a given Payload Format is relative to other Payload Formats, where an
 *          "A+" equates to a simple memcpy in C++ and a "D" equates to a complex
 *          processing algorithm with nested loops and heavy use of bit manipulation.
 *          In practice the speed difference in speed between a "B" and an "A" is
 *          small whereas the difference between a "B" and a "D" is many orders of
 *          magnitude slower. <i>(For example, on one test of ~2 million iterations using
 *          both link efficient ("D") and processing efficient ("B") and with Packing
 *          Field Sizes between 33 and 63 bits it took 38.2 sec for link efficient vs
 *          &lt;0.1 sec for processing efficient.)</i>
 *      [1] All Data items are signed/unsigned integers with the bit count as shown,
 *          except for "float" and "double" which represent IEEE-754 floating-point
 *          values.
 *      [2] Fast handling of Int1 and Int4/Int12 data by unpacking eight/two elements
 *          at a time. Total length must be a multiple of 8/2 to use this mode.
 *      [3] Event/Channel tags (if present) are not read and set to zero on write.
 *      [4] Future versions may provide a faster implementation for 1 to 15 bit
 *          field sizes when in Processing Efficient mode.
 *  </pre>
 *  Currently all of the VRT floating-point formats are using algorithms that
 *  are similar to the "D+" and "D" ones used for IEEE-754 float data. Future
 *  versions may provide a faster implementation for situations where the data
 *  item size is 8/16/32/64 bits and/or processing-efficient mode is used. <br>
 *  <br>
 *  Regardless of the algorithm used herein, the accessing of IEEE-754
 *  floating-point values will always be faster than the accessing of VRT
 *  floating-point values since the former benefit from hardware acceleration.
 * 
 *  @author Auto-Generated   (source code)
 *  @author  (code template)
 */
public final class PackUnpack {
  private PackUnpack () { } // prevents instantiation

  /** <b>Internal Use Only:</b> Fast unpack method for double data.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits (must be 64)
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed? (must be true)
   */
  @SuppressWarnings("cast")
  private static  void unpackDoubles (byte[] buf, int off, double[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    // All floating-point values are signed, so 'sign' is unused, but is included
    // in function definition for consistency.
    // When using Double data, it is required that dSize=64 and fSize=64 so we can
    // skip some of the normal checks we would otherwise do here.
    for (int i = 0; i < length; i++,off+=8) {
      array[offset++] = (double)unpackDouble(buf, off);
    }
  }
  /** <b>Internal Use Only:</b>
   *  Fast pack method for double data.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits (must be 64)
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed? (must be true)
   */
  @SuppressWarnings("cast")
  private static  void packDoubles (byte[] buf, int off, double[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    // All floating-point values are signed, so 'sign' is unused, but is included
    // in function definition for consistency.
    // When using Double data, it is required that dSize=64 and fSize=64 so we can
    // skip some of the normal checks we would otherwise do here.
    for (int i = 0; i < length; i++,off+=8) {
      packDouble(buf, off, (double)array[offset++]);
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for float data.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits (must be 32)
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed? (must be true)
   */
  @SuppressWarnings("cast")
  private static  void unpackFloats (byte[] buf, int off, double[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    // All floating-point values are signed, so 'sign' is unused, but is included
    // in function definition for consistency.
    int delta; // byte offset delta
    if (align) delta = (fSize <= 32)? 4 : 8;
    else       delta = fSize / 8;
    for (int i = 0; i < length; i++,off+=delta) {
      array[offset++] = (double)unpackFloat(buf, off);
    }
  }
  /** <b>Internal Use Only:</b>
   *  Fast pack method for float data.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits (must be 32)
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed? (must be true)
   */
  @SuppressWarnings("cast")
  private static  void packFloats (byte[] buf, int off, double[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    // All floating-point values are signed, so 'sign' is unused, but is included
    // in function definition for consistency.
    int delta; // byte offset delta
    if (align) delta = (fSize <= 32)? 4 : 8;
    else       delta = fSize / 8;
    if (delta == 4) {
      for (int i = 0; i < length; i++,off+=4) {
        packFloat(buf, off, (float)array[offset++]);
      }
    }
    else {
      for (int i = 0; i < length; i++) {
        packFloat(buf, off, (float)array[offset++]);
        off += 4;
        for (int j = 4; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for signed long data.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void unpackLongs (byte[] buf, int off, double[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // byte offset delta
    if (sign) {
      if (dSize == 64) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (double)unpackLong(buf, off);
        }
      }
      else {
        int shift  = 64 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (double)(unpackLong(buf, off) >> shift);
        }
      }
    }
    else {
      if (dSize == 64) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (double)(unpackLong(buf, off) & 0xFFFFFFFFFFFFFFFFL);
        }
      }
      else {
        int shift  = 64 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (double)((unpackLong(buf, off) & 0xFFFFFFFFFFFFFFFFL) >>> shift);
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast pack method for unsigned long data.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void packLongs (byte[] buf, int off, double[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // byte offset delta
    long valMask = (sign)? ((long)-1) : ((long)0xFFFFFFFFFFFFFFFFL); // Bit mask for input value (controls sign-extend)
    if (dSize == 64) {
      if (delta == 8) {
        for (int i = 0; i < length; i++,off+=8) {
          long val = (long)(((long)(long)array[offset++]) & valMask);
          packLong(buf, off, val);
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          long val = (long)(((long)(long)array[offset++]) & valMask);
          packLong(buf, off, val);
          off += 8;
          for (int j = 8; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
    else {
      int shift = 64 - dSize;
      if (delta == 8) {
        for (int i = 0; i < length; i++,off+=8) {
          long val = (long)(((long)(long)array[offset++]) & valMask);
          packLong(buf, off, (long)(val << shift));
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          long val = (long)(((long)(long)array[offset++]) & valMask);
          packLong(buf, off, (long)(val << shift));
          off += 8;
          for (int j = 8; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for signed int data.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void unpackInts (byte[] buf, int off, double[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // byte offset delta
    if (sign) {
      if (dSize == 32) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (double)unpackInt(buf, off);
        }
      }
      else {
        int shift  = 32 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (double)(unpackInt(buf, off) >> shift);
        }
      }
    }
    else {
      if (dSize == 32) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (double)(unpackInt(buf, off) & 0xFFFFFFFFL);
        }
      }
      else {
        int shift  = 32 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (double)((unpackInt(buf, off) & 0xFFFFFFFFL) >>> shift);
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast pack method for unsigned int data.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void packInts (byte[] buf, int off, double[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // byte offset delta
    int valMask = (sign)? ((int)-1) : ((int)0xFFFFFFFFFFFFFFFFL); // Bit mask for input value (controls sign-extend)
    if (dSize == 32) {
      if (delta == 4) {
        for (int i = 0; i < length; i++,off+=4) {
          int val = (int)(((int)(long)array[offset++]) & valMask);
          packInt(buf, off, val);
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          int val = (int)(((int)(long)array[offset++]) & valMask);
          packInt(buf, off, val);
          off += 4;
          for (int j = 4; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
    else {
      int shift = 32 - dSize;
      if (delta == 4) {
        for (int i = 0; i < length; i++,off+=4) {
          int val = (int)(((int)(long)array[offset++]) & valMask);
          packInt(buf, off, (int)(val << shift));
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          int val = (int)(((int)(long)array[offset++]) & valMask);
          packInt(buf, off, (int)(val << shift));
          off += 4;
          for (int j = 4; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for signed int data.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void unpackInt24s (byte[] buf, int off, double[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // byte offset delta
    if (sign) {
      if (dSize == 24) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (double)unpackInt24(buf, off);
        }
      }
      else {
        int shift  = 24 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (double)(unpackInt24(buf, off) >> shift);
        }
      }
    }
    else {
      if (dSize == 24) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (double)(unpackInt24(buf, off) & 0xFFFFFFL);
        }
      }
      else {
        int shift  = 24 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (double)((unpackInt24(buf, off) & 0xFFFFFFL) >>> shift);
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast pack method for unsigned int data.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void packInt24s (byte[] buf, int off, double[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // byte offset delta
    int valMask = (sign)? ((int)-1) : ((int)0xFFFFFFFFFFFFFFFFL); // Bit mask for input value (controls sign-extend)
    if (dSize == 24) {
      if (delta == 3) {
        for (int i = 0; i < length; i++,off+=3) {
          int val = (int)(((int)(long)array[offset++]) & valMask);
          packInt24(buf, off, val);
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          int val = (int)(((int)(long)array[offset++]) & valMask);
          packInt24(buf, off, val);
          off += 3;
          for (int j = 3; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
    else {
      int shift = 24 - dSize;
      if (delta == 3) {
        for (int i = 0; i < length; i++,off+=3) {
          int val = (int)(((int)(long)array[offset++]) & valMask);
          packInt24(buf, off, (int)(val << shift));
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          int val = (int)(((int)(long)array[offset++]) & valMask);
          packInt24(buf, off, (int)(val << shift));
          off += 3;
          for (int j = 3; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for signed short data.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void unpackShorts (byte[] buf, int off, double[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = fSize / 8; // byte offset delta
    if (sign) {
      if (dSize == 16) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (double)unpackShort(buf, off);
        }
      }
      else {
        int shift  = 16 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (double)(unpackShort(buf, off) >> shift);
        }
      }
    }
    else {
      if (dSize == 16) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (double)(unpackShort(buf, off) & 0xFFFFL);
        }
      }
      else {
        int shift  = 16 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (double)((unpackShort(buf, off) & 0xFFFFL) >>> shift);
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast pack method for unsigned short data.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void packShorts (byte[] buf, int off, double[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = fSize / 8; // byte offset delta
    short valMask = (sign)? ((short)-1) : ((short)0xFFFFFFFFFFFFFFFFL); // Bit mask for input value (controls sign-extend)
    if (dSize == 16) {
      if (delta == 2) {
        for (int i = 0; i < length; i++,off+=2) {
          short val = (short)(((short)(long)array[offset++]) & valMask);
          packShort(buf, off, val);
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          short val = (short)(((short)(long)array[offset++]) & valMask);
          packShort(buf, off, val);
          off += 2;
          for (int j = 2; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
    else {
      int shift = 16 - dSize;
      if (delta == 2) {
        for (int i = 0; i < length; i++,off+=2) {
          short val = (short)(((short)(long)array[offset++]) & valMask);
          packShort(buf, off, (short)(val << shift));
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          short val = (short)(((short)(long)array[offset++]) & valMask);
          packShort(buf, off, (short)(val << shift));
          off += 2;
          for (int j = 2; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for signed Int12 data.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
   *  @param fSize  (IN)  Item packing field size in bits (must be 12)
   *  @param dSize  (IN)  Data item size in bits (must be 12)
   *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackInt12s (byte[] buf, int off, double[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int skip = (align)? 1 : 0;
    if (sign) {
      for (int i = 0; i < length; i+=2) {
        int a = (int)buf[off++];
        int b = (int)buf[off++];
        int c = (int)buf[off++];
        int x = (a << 4) | ((b >> 4) & 0x000F);
        int y = (b << 8) | ((c     ) & 0x00FF);
        array[offset++] = (double)((x << 20) >> 20); // sign extend
        array[offset++] = (double)((y << 20) >> 20); // sign extend
        off += skip; // skip extra byte in processing-efficient mode
      }
    }
    else {
      for (int i = 0; i < length; i+=2) {
        int a = (int)buf[off++];
        int b = (int)buf[off++];
        int c = (int)buf[off++];
        int x = (a << 4) | ((b >> 4) & 0x000F);
        int y = (b << 8) | ((c     ) & 0x00FF);
        array[offset++] = (double)(x & 0x0FFF); // clear high-order bits
        array[offset++] = (double)(y & 0x0FFF); // clear high-order bits
        off += skip; // skip extra byte in processing-efficient mode
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast pack method for signed Int12 data.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
   *  @param fSize  (IN)  Item packing field size in bits (must be 12)
   *  @param dSize  (IN)  Data item size in bits (must be 12)
   *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packInt12s (byte[] buf, int off, double[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int skip = (align)?  1 : 0;
    int mask = (sign )? -1 : ((int)0xFFFFFFFFFFFFFFFFL);
    for (int i = 0; i < length; i+=2) {
      int first  = ((int)(long)array[offset++]) & mask;
      int second = ((int)(long)array[offset++]) & mask;
      buf[off++] = (byte)(first >> 4);
      buf[off++] = (byte)((first << 4) | ((second >> 8) & 0x0F));
      buf[off++] = (byte)(second);
      off += skip; // skip extra byte in processing-efficient mode
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for signed byte data.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void unpackBytes (byte[] buf, int off, double[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = fSize / 8; // byte offset delta
    if (sign) {
      if (dSize == 8) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (double)unpackByte(buf, off);
        }
      }
      else {
        int shift  = 8 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (double)(unpackByte(buf, off) >> shift);
        }
      }
    }
    else {
      if (dSize == 8) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (double)(unpackByte(buf, off) & 0xFFL);
        }
      }
      else {
        int shift  = 8 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (double)((unpackByte(buf, off) & 0xFFL) >>> shift);
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast pack method for unsigned byte data.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void packBytes (byte[] buf, int off, double[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = fSize / 8; // byte offset delta
    byte valMask = (sign)? ((byte)-1) : ((byte)0xFFFFFFFFFFFFFFFFL); // Bit mask for input value (controls sign-extend)
    if (dSize == 8) {
      if (delta == 1) {
        for (int i = 0; i < length; i++,off+=1) {
          byte val = (byte)(((byte)(long)array[offset++]) & valMask);
          packByte(buf, off, val);
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          byte val = (byte)(((byte)(long)array[offset++]) & valMask);
          packByte(buf, off, val);
          off += 1;
          for (int j = 1; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
    else {
      int shift = 8 - dSize;
      if (delta == 1) {
        for (int i = 0; i < length; i++,off+=1) {
          byte val = (byte)(((byte)(long)array[offset++]) & valMask);
          packByte(buf, off, (byte)(val << shift));
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          byte val = (byte)(((byte)(long)array[offset++]) & valMask);
          packByte(buf, off, (byte)(val << shift));
          off += 1;
          for (int j = 1; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for signed Int4 (nibble) data.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
   *  @param fSize  (IN)  Item packing field size in bits (must be 4)
   *  @param dSize  (IN)  Data item size in bits (must be 4)
   *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackNibbles (byte[] buf, int off, double[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    if (sign) {
      for (int i = 0; i < length; i+=2) {
        int b = (int)buf[off++];
        array[offset++] = (double)((b << 24) >> 28); // shift & sign extend
        array[offset++] = (double)((b << 28) >> 28); // shift & sign extend
      }
    }
    else {
      for (int i = 0; i < length; i+=2) {
        int b = (int)buf[off++];
        array[offset++] = (double)((b >> 4) & 0xF);
        array[offset++] = (double)((b     ) & 0xF);
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast pack method for signed Int4 (nibble) data.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
   *  @param fSize  (IN)  Item packing field size in bits (must be 4)
   *  @param dSize  (IN)  Data item size in bits (must be 4)
   *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packNibbles (byte[] buf, int off, double[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    // Pack function for signed and are identical for nibble data, hence
    // 'sign' is unused here, but included in function definition for consistency.
    for (int i = 0; i < length; i+=2) {
      int first  = (int)(long)array[offset++];
      int second = (int)(long)array[offset++];
      buf[off++] = (byte)((first << 4) | (second & 0xF));
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for bit data. Each bit in the
   *  input buffer will be checked, a 0 bit will correspond to the value 0 and a
   *  1 bit will correspond to the value 1.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert (must be a multiple of 8)
   *  @param fSize  (IN)  Item packing field size in bits (must be 1)
   *  @param dSize  (IN)  Data item size in bits (must be 1)
   *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackBits (byte[] buf, int off, double[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    if (sign) {
      // This uses sign-extending principles to get each bit as 0 or -1 which reflects
      // the fact that 0/-1 and not 0/+1 are the available values in a one-bit use of
      // twos-complement.
      for (int i = 0; i < length; i+=8) {
        int b = (int)buf[off++];
        array[offset++] = (double)((b << 24) >> 31);
        array[offset++] = (double)((b << 25) >> 31);
        array[offset++] = (double)((b << 26) >> 31);
        array[offset++] = (double)((b << 27) >> 31);
        array[offset++] = (double)((b << 28) >> 31);
        array[offset++] = (double)((b << 29) >> 31);
        array[offset++] = (double)((b << 30) >> 31);
        array[offset++] = (double)((b << 31) >> 31);
      }
    }
    else {
      for (int i = 0; i < length; i+=8) {
        int b = (int)buf[off++];
        array[offset++] = (double)((b >> 7) & 0x1);
        array[offset++] = (double)((b >> 6) & 0x1);
        array[offset++] = (double)((b >> 5) & 0x1);
        array[offset++] = (double)((b >> 4) & 0x1);
        array[offset++] = (double)((b >> 3) & 0x1);
        array[offset++] = (double)((b >> 2) & 0x1);
        array[offset++] = (double)((b >> 1) & 0x1);
        array[offset++] = (double)((b     ) & 0x1);
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast pack method for bit data. Each value in the
   *  input array will be checked, a zero value will correspond to the bit 0 and
   *  any non-zero value will correspond to the bit 1.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert (must be a multiple of 8)
   *  @param fSize  (IN)  Item packing field size in bits (must be 1)
   *  @param dSize  (IN)  Data item size in bits (must be 1)
   *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packBits (byte[] buf, int off, double[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    // Pack function for signed and are identical for bit data, hence
    // 'sign' is unused here, but included in function definition for consistency.
    for (int i = 0; i < length; i+=8) {
      int b = 0;
      b |= (((long)array[offset++]) << 7) & 0x80;
      b |= (((long)array[offset++]) << 6) & 0x40;
      b |= (((long)array[offset++]) << 5) & 0x20;
      b |= (((long)array[offset++]) << 4) & 0x10;
      b |= (((long)array[offset++]) << 3) & 0x08;
      b |= (((long)array[offset++]) << 2) & 0x04;
      b |= (((long)array[offset++]) << 1) & 0x02;
      b |= (((long)array[offset++])     ) & 0x01;
      buf[off++] = (byte)b;
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array, where the data is
   *  aligned to 32-bit word boundaries.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array  (OUT) Output value array (not null)
   *  @param chan   (OUT) Output channel tag array (null if n/a)
   *  @param evt    (OUT) Output event tag array (null if n/a)
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits
   *  @param dSize  (IN)  Data item size in bits
   *  @param eSize  (IN)  Event tag size in bits
   *  @param cSize  (IN)  Channel tag size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackIntWord32 (byte[] buf, int off, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+- - - - - +
    //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
    //   +-----------+--------+-----------+-------------+- - - - - +
    //       dSize      uSize     eSize       cSize        pSize
    //   |------------------ fSize ---------------------|
    //   |---------------------- Word Size ------------------------|
    int    pSize    = 32 - fSize;
    int    evtMask  = ~(((int)-1) << eSize);
    int    chanMask = ~(((int)-1) << cSize);
    int valMask  = (sign)? ((int)-1) : (~(((int)-1) << dSize));
    for (int i = 0; i < length; i++,off+=4) {
      int value = unpackInt(buf, off);
      array[i] = (double)((value >> (32-dSize)) & valMask);
      if (chan != null) chan[i] = (value >> (pSize      )) & chanMask;
      if (evt  != null) evt[i]  = (value >> (pSize+cSize)) & evtMask;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array, where the data is
   *  aligned to 32-bit word boundaries.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input value array
   *  @param chan   (IN)  Input channel tag array (null if n/a)
   *  @param evt    (IN)  Input event tag array (null if n/a)
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits
   *  @param dSize  (IN)  Data item size in bits
   *  @param eSize  (IN)  Event tag size in bits
   *  @param cSize  (IN)  Channel tag size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packIntWord32 (byte[] buf, int off, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+- - - - - +
    //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
    //   +-----------+--------+-----------+-------------+- - - - - +
    //       dSize      uSize     eSize       cSize        pSize
    //   |------------------ fSize ---------------------|
    //   |---------------------- Word Size ------------------------|
    int    pSize    = 32 - fSize;
    int    evtMask  = ~(((int)-1) << eSize);
    int    chanMask = ~(((int)-1) << cSize);
    int valMask  = (sign)? ((int)-1) : ((int)0xFFFFFFFFFFFFFFFFL);
    for (int i = 0; i < length; i++,off+=4) {
      int val   = (int)(((int)(long)array[i]) & valMask);
      int value = val << (32-dSize);
      if (chan != null) value |= (chan[i] & chanMask) << (pSize);
      if (evt  != null) value |= (evt[i]  & evtMask ) << (pSize+cSize);
      packInt(buf, off, value);
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array, where the data is
   *  aligned to 64-bit word boundaries.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array  (OUT) Output value array (not null)
   *  @param chan   (OUT) Output channel tag array (null if n/a)
   *  @param evt    (OUT) Output event tag array (null if n/a)
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits
   *  @param dSize  (IN)  Data item size in bits
   *  @param eSize  (IN)  Event tag size in bits
   *  @param cSize  (IN)  Channel tag size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackIntWord64 (byte[] buf, int off, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+- - - - - +
    //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
    //   +-----------+--------+-----------+-------------+- - - - - +
    //       dSize      uSize     eSize       cSize        pSize
    //   |------------------ fSize ---------------------|
    //   |---------------------- Word Size ------------------------|
    int    pSize    = 64 - fSize;
    int    evtMask  = ~(((int)-1) << eSize);
    int    chanMask = ~(((int)-1) << cSize);
    long valMask  = (sign)? ((long)-1) : (~(((long)-1) << dSize));
    if (dSize == 32) {
      // When using Int32/UInt32 the first 32-bits will always the the Int32/UInt32
      // value, so use 32-bit operations to improve performance
      for (int i = 0; i < length; i++,off+=8) {
        int val   = unpackInt(buf, off);
        int value = unpackInt(buf, off+4);
        array[i] = (double)(val & valMask);
        if (chan != null) chan[i] = ((int)(value >> (pSize      ))) & chanMask;
        if (evt  != null) evt[i]  = ((int)(value >> (pSize+cSize))) & evtMask;
      }
    }
    else {
      for (int i = 0; i < length; i++,off+=8) {
        long value = unpackLong(buf, off);
        array[i] = (double)((value >> (64-dSize)) & valMask);
        if (chan != null) chan[i] = ((int)(value >> (pSize      ))) & chanMask;
        if (evt  != null) evt[i]  = ((int)(value >> (pSize+cSize))) & evtMask;
      }
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array, where the data is
   *  aligned to 64-bit word boundaries.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input value array
   *  @param chan   (IN)  Input channel tag array (null if n/a)
   *  @param evt    (IN)  Input event tag array (null if n/a)
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits
   *  @param dSize  (IN)  Data item size in bits
   *  @param eSize  (IN)  Event tag size in bits
   *  @param cSize  (IN)  Channel tag size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packIntWord64 (byte[] buf, int off, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+- - - - - +
    //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
    //   +-----------+--------+-----------+-------------+- - - - - +
    //       dSize      uSize     eSize       cSize        pSize
    //   |------------------ fSize ---------------------|
    //   |---------------------- Word Size ------------------------|
    int    pSize    = 64 - fSize;
    int    evtMask  = ~(((int)-1) << eSize);
    int    chanMask = ~(((int)-1) << cSize);
    long valMask  = (sign)? ((long)-1) : ((long)0xFFFFFFFFFFFFFFFFL);
    if (dSize == 32) {
      // When using Int32/UInt32 the first 32-bits will always the the Int32/UInt32
      // value, so use 32-bit operations to improve performance
      for (int i = 0; i < length; i++,off+=8) {
        int val   = (int)(((long)(long)array[i]) & valMask);
        int value = 0;
        if (chan != null) value  = (chan[i] & chanMask) << (pSize);
        if (evt  != null) value |= (evt[i]  & evtMask ) << (pSize+cSize);
        packInt(buf, off,   val);
        packInt(buf, off+4, value);
      }
    }
    else {
      for (int i = 0; i < length; i++,off+=8) {
        long val   = (long)(((long)(long)array[i]) & valMask);
        long value = val << (64-dSize);
        if (chan != null) value |= ((long)(chan[i] & chanMask)) << (pSize);
        if (evt  != null) value |= ((long)(evt[i]  & evtMask )) << (pSize+cSize);
        packLong(buf, off, value);
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array, where the data is
   *  aligned to 64-bit word boundaries.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array  (OUT) Output value array (not null)
   *  @param chan   (OUT) Output channel tag array (null if n/a)
   *  @param evt    (OUT) Output event tag array (null if n/a)
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits
   *  @param dSize  (IN)  Data item size in bits
   *  @param eSize  (IN)  Event tag size in bits
   *  @param cSize  (IN)  Channel tag size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackFloatWord64 (byte[] buf, int off, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+- - - - - +
    //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
    //   +-----------+--------+-----------+-------------+- - - - - +
    //       dSize      uSize     eSize       cSize        pSize
    //   |------------------ fSize ---------------------|
    //   |---------------------- Word Size ------------------------|
    int    pSize    = 64 - fSize;
    int    evtMask  = ~(((int)-1) << eSize);
    int    chanMask = ~(((int)-1) << cSize);
    // When using Float32 the first 32-bits will always the the Float32 value, so
    // use 32-bit operations to improve performance
    for (int i = 0; i < length; i++,off+=8) {
      array[i] = (double)unpackFloat(buf, off);
      int value = unpackInt(buf, off+4);
      if (chan != null) chan[i] = (value >> (pSize      )) & chanMask;
      if (evt  != null) evt[i]  = (value >> (pSize+cSize)) & evtMask;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array, where the data is
   *  aligned to 64-bit word boundaries.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input value array
   *  @param chan   (IN)  Input channel tag array (null if n/a)
   *  @param evt    (IN)  Input event tag array (null if n/a)
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits
   *  @param dSize  (IN)  Data item size in bits
   *  @param eSize  (IN)  Event tag size in bits
   *  @param cSize  (IN)  Channel tag size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packFloatWord64 (byte[] buf, int off, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+- - - - - +
    //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
    //   +-----------+--------+-----------+-------------+- - - - - +
    //       dSize      uSize     eSize       cSize        pSize
    //   |------------------ fSize ---------------------|
    //   |---------------------- Word Size ------------------------|
    int    pSize    = 64 - fSize;
    int    evtMask  = ~(((int)-1) << eSize);
    int    chanMask = ~(((int)-1) << cSize);
    // When using Float32 the first 32-bits will always the the Float32 value, so
    // use 32-bit operations to improve performance
    for (int i = 0; i < length; i++,off+=8) {
      float val   = (float)array[i];
      int   value = 0;
      if (chan != null) value  = (chan[i] & chanMask) << (pSize);
      if (evt  != null) value |= (evt[i]  & evtMask ) << (pSize+cSize);
      packFloat(buf, off,   val);
      packInt(  buf, off+4, value);
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackIntBuffer32 (byte[] buf, int bitOffset, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_dSize  = 32 - dSize;    // pre-compute "32 - dSize" for efficiency
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        if (sign) {
          // sign extend
          array[offset] = (double)((value << _bits_dSize) >>  _bits_dSize);
        }
        else {
          // leave top bits (which default to 0) as 0
          array[offset] = (double)value;
        }
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packIntBuffer32 (byte[] buf, int bitOffset, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    int valMask      = (sign)? ((int)-1) : ((int)0xFFFFFFFFFFFFFFFFL); // Bit mask for input value (controls sign-extend)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        int arrayValue = ((int)(long)array[offset]) & valMask;
        int value      = (int)((arrayValue) << (32 - dSize));
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackIntBuffer64 (byte[] buf, int bitOffset, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_dSize  = 64 - dSize;    // pre-compute "64 - dSize" for efficiency
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        if (sign) {
          // sign extend
          array[offset] = (double)((value << _bits_dSize) >>  _bits_dSize);
        }
        else {
          // leave top bits (which default to 0) as 0
          array[offset] = (double)value;
        }
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packIntBuffer64 (byte[] buf, int bitOffset, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    long valMask      = (sign)? ((long)-1) : ((long)0xFFFFFFFFFFFFFFFFL); // Bit mask for input value (controls sign-extend)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        long arrayValue = ((long)(long)array[offset]) & valMask;
        long value      = (long)((arrayValue) << (64 - dSize));
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackFloatBuffer64 (byte[] buf, int bitOffset, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (double)intBitsToFloat((int)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packFloatBuffer64 (byte[] buf, int bitOffset, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        float  arrayValue = (float)array[offset];
        long   value      = ((long)floatToRawIntBits(arrayValue)) << 32;
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT1Buffer32 (byte[] buf, int bitOffset, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (double)fromVRTFloat(DataItemFormat.SignedVRT1, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT1Buffer32 (byte[] buf, int bitOffset, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.SignedVRT1, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT1Buffer64 (byte[] buf, int bitOffset, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (double)fromVRTFloat(DataItemFormat.SignedVRT1, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT1Buffer64 (byte[] buf, int bitOffset, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.SignedVRT1, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT2Buffer32 (byte[] buf, int bitOffset, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (double)fromVRTFloat(DataItemFormat.SignedVRT2, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT2Buffer32 (byte[] buf, int bitOffset, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.SignedVRT2, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT2Buffer64 (byte[] buf, int bitOffset, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (double)fromVRTFloat(DataItemFormat.SignedVRT2, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT2Buffer64 (byte[] buf, int bitOffset, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.SignedVRT2, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT3Buffer32 (byte[] buf, int bitOffset, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (double)fromVRTFloat(DataItemFormat.SignedVRT3, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT3Buffer32 (byte[] buf, int bitOffset, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.SignedVRT3, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT3Buffer64 (byte[] buf, int bitOffset, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (double)fromVRTFloat(DataItemFormat.SignedVRT3, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT3Buffer64 (byte[] buf, int bitOffset, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.SignedVRT3, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT4Buffer32 (byte[] buf, int bitOffset, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (double)fromVRTFloat(DataItemFormat.SignedVRT4, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT4Buffer32 (byte[] buf, int bitOffset, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.SignedVRT4, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT4Buffer64 (byte[] buf, int bitOffset, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (double)fromVRTFloat(DataItemFormat.SignedVRT4, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT4Buffer64 (byte[] buf, int bitOffset, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.SignedVRT4, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT5Buffer32 (byte[] buf, int bitOffset, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (double)fromVRTFloat(DataItemFormat.SignedVRT5, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT5Buffer32 (byte[] buf, int bitOffset, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.SignedVRT5, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT5Buffer64 (byte[] buf, int bitOffset, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (double)fromVRTFloat(DataItemFormat.SignedVRT5, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT5Buffer64 (byte[] buf, int bitOffset, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.SignedVRT5, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT6Buffer32 (byte[] buf, int bitOffset, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (double)fromVRTFloat(DataItemFormat.SignedVRT6, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT6Buffer32 (byte[] buf, int bitOffset, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.SignedVRT6, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT6Buffer64 (byte[] buf, int bitOffset, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (double)fromVRTFloat(DataItemFormat.SignedVRT6, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT6Buffer64 (byte[] buf, int bitOffset, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.SignedVRT6, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT1Buffer32 (byte[] buf, int bitOffset, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (double)fromVRTFloat(DataItemFormat.UnsignedVRT1, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT1Buffer32 (byte[] buf, int bitOffset, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.UnsignedVRT1, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT1Buffer64 (byte[] buf, int bitOffset, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (double)fromVRTFloat(DataItemFormat.UnsignedVRT1, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT1Buffer64 (byte[] buf, int bitOffset, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.UnsignedVRT1, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT2Buffer32 (byte[] buf, int bitOffset, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (double)fromVRTFloat(DataItemFormat.UnsignedVRT2, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT2Buffer32 (byte[] buf, int bitOffset, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.UnsignedVRT2, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT2Buffer64 (byte[] buf, int bitOffset, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (double)fromVRTFloat(DataItemFormat.UnsignedVRT2, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT2Buffer64 (byte[] buf, int bitOffset, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.UnsignedVRT2, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT3Buffer32 (byte[] buf, int bitOffset, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (double)fromVRTFloat(DataItemFormat.UnsignedVRT3, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT3Buffer32 (byte[] buf, int bitOffset, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.UnsignedVRT3, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT3Buffer64 (byte[] buf, int bitOffset, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (double)fromVRTFloat(DataItemFormat.UnsignedVRT3, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT3Buffer64 (byte[] buf, int bitOffset, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.UnsignedVRT3, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT4Buffer32 (byte[] buf, int bitOffset, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (double)fromVRTFloat(DataItemFormat.UnsignedVRT4, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT4Buffer32 (byte[] buf, int bitOffset, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.UnsignedVRT4, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT4Buffer64 (byte[] buf, int bitOffset, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (double)fromVRTFloat(DataItemFormat.UnsignedVRT4, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT4Buffer64 (byte[] buf, int bitOffset, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.UnsignedVRT4, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT5Buffer32 (byte[] buf, int bitOffset, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (double)fromVRTFloat(DataItemFormat.UnsignedVRT5, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT5Buffer32 (byte[] buf, int bitOffset, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.UnsignedVRT5, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT5Buffer64 (byte[] buf, int bitOffset, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (double)fromVRTFloat(DataItemFormat.UnsignedVRT5, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT5Buffer64 (byte[] buf, int bitOffset, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.UnsignedVRT5, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT6Buffer32 (byte[] buf, int bitOffset, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (double)fromVRTFloat(DataItemFormat.UnsignedVRT6, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT6Buffer32 (byte[] buf, int bitOffset, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.UnsignedVRT6, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT6Buffer64 (byte[] buf, int bitOffset, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (double)fromVRTFloat(DataItemFormat.UnsignedVRT6, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT6Buffer64 (byte[] buf, int bitOffset, double[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.UnsignedVRT6, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Unpacks values with the given format specifier as
   *  an array of <tt>double</tt>. <br>
   *  <br>
   *  Setting the channel tags (<tt>chan</tt>) and/or event tags (<tt>evt</tt>)
   *  arrays to null will cause any channel or event tags present to be ignored.
   *  In most cases this results in a performance improvement. <br>
   *  <br>
   *  If the channel tags (<tt>chan</tt>) and/or event tags (<tt>evt</tt>) arrays
   *  are non-null when there are no channel or event tags present, the values in
   *  the arrays will not be modified.
   *  @param pf     (IN)  The data format
   *  @param buf    (IN)  The buffer
   *  @param off    (IN)  The buffer offset
   *  @param array  (OUT) The output array for the values
   *  @param chan   (OUT) The output array for the channel tags (null if n/a)
   *  @param evt    (OUT) The output array for the event tags (null if n/a)
   *  @param length (IN)  Number of elements to convert
   *  @return The output array (same as <tt>array</tt>).
   */
  @SuppressWarnings("fallthrough")
  public static double[] unpackAsDouble (PayloadFormat pf, byte[] buf, int off, double[] array, int[] chan, int[] evt, int length) {
    if (!pf.isValid()) {
      throw new IllegalArgumentException(pf.getValid());
    }
    int            fSize  = pf.getItemPackingFieldSize();
    int            dSize  = pf.getDataItemSize();
    int            eSize  = pf.getEventTagSize();
    int            cSize  = pf.getChannelTagSize();
    boolean        proc   = pf.isProcessingEfficient();
    boolean        sign   = pf.isSigned();
    DataItemFormat format = pf.getDataItemFormat();
    boolean        noTags;
    if (eSize == 0) evt  = null; // no event tags, ignore any array passed in
    if (cSize == 0) chan = null; // no channel tags, ignore any array passed in
    noTags = (chan == null) && (evt == null);
    if (proc && noTags && (fSize >= 17)) {
      // Use faster "effective field size" when ignoring Event & Channel Tags
      fSize = (fSize <= 32)? 32 : 64;
    }
    switch (format) {
      case SignedInt:   // FALLTHROUGH
      case UnsignedInt:
        // ---- Try fast methods -------------------------------------------------
        if (noTags) {
          switch (fSize) {
            case  8: unpackBytes(  buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
            case 16: unpackShorts( buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
            case 24: unpackInt24s( buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
            case 32: unpackInts(   buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
            case 64: unpackLongs(  buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
          }
        }
        if (fSize == dSize) { // implicit noTags=true in this case
          switch (fSize) {
            case  1: if ((length % 8) == 0) { unpackBits(   buf, off, array, 0, length, fSize, dSize, proc, sign); return array; } break;
            case  4: if ((length % 2) == 0) { unpackNibbles(buf, off, array, 0, length, fSize, dSize, proc, sign); return array; } break;
            case 12: if ((length % 2) == 0) { unpackInt12s( buf, off, array, 0, length, fSize, dSize, proc, sign); return array; } break;
          }
        }
        if ((proc && (fSize >= 17)) || (fSize == 32) || (fSize == 64)) {
          if (fSize <= 32) {
            unpackIntWord32(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
          }
          else {
            unpackIntWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
          }
        }
        // ---- Fall back to slow method -----------------------------------------
        if (fSize <= 32) {
          unpackIntBuffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackIntBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case Float:
        // ---- Try fast methods -------------------------------------------------
        if (fSize == dSize) { // implicit noTags=true in this case
          unpackFloats(buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
        }
        if ((proc && (fSize >= 33)) || (fSize == 64)) {
          unpackFloatWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        // ---- Fall back to slow method -----------------------------------------
        unpackFloatBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      case Double:
        // ---- Only fast method for double (yea!) -------------------------------
        unpackDoubles(buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
      case SignedVRT1:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackSignedVRT1Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackSignedVRT1Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case SignedVRT2:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackSignedVRT2Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackSignedVRT2Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case SignedVRT3:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackSignedVRT3Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackSignedVRT3Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case SignedVRT4:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackSignedVRT4Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackSignedVRT4Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case SignedVRT5:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackSignedVRT5Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackSignedVRT5Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case SignedVRT6:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackSignedVRT6Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackSignedVRT6Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case UnsignedVRT1:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackUnsignedVRT1Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackUnsignedVRT1Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case UnsignedVRT2:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackUnsignedVRT2Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackUnsignedVRT2Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case UnsignedVRT3:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackUnsignedVRT3Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackUnsignedVRT3Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case UnsignedVRT4:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackUnsignedVRT4Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackUnsignedVRT4Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case UnsignedVRT5:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackUnsignedVRT5Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackUnsignedVRT5Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case UnsignedVRT6:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackUnsignedVRT6Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackUnsignedVRT6Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      default:
        throw new UnsupportedOperationException("Unpacking of VRT float types not supported yet");
    }
  }
  /** <b>Internal Use Only:</b> Packs values with the given format specifier from
   *  an array of double. <br>
   *  <br>
   *  Setting the channel tags (<tt>chan</tt>) and/or event tags (<tt>evt</tt>)
   *  arrays to null will cause any channel or event tags present to be set to
   *  zero. In most cases this results in a performance improvement over passing
   *  in an array of zeros. <br>
   *  <br>
   *  If the channel tags (<tt>chan</tt>) and/or event tags (<tt>evt</tt>) arrays
   *  are non-null when there are no channel or event tags present, the values in
   *  the arrays will be ignored.
   *  @param pf     (IN)  The data format
   *  @param buf    (I/O) The buffer
   *  @param off    (IN)  The buffer offset
   *  @param array  (IN)  The values to pack
   *  @param chan   (OUT) The output array for the channel tags (null if n/a)
   *  @param evt    (OUT) The output array for the event tags (null if n/a)
   *  @param length (IN)  Number of elements to convert
   */
  @SuppressWarnings("fallthrough")
  public static void packAsDouble (PayloadFormat pf, byte[] buf, int off, double[] array, int[] chan, int[] evt, int length) {
    if (!pf.isValid()) {
      throw new IllegalArgumentException(pf.getValid());
    }
    int            fSize  = pf.getItemPackingFieldSize();
    int            dSize  = pf.getDataItemSize();
    int            eSize  = pf.getEventTagSize();
    int            cSize  = pf.getChannelTagSize();
    boolean        proc   = pf.isProcessingEfficient();
    boolean        sign   = pf.isSigned();
    DataItemFormat format = pf.getDataItemFormat();
    boolean        noTags;
    if (eSize == 0) evt  = null; // no event tags, ignore any array passed in
    if (cSize == 0) chan = null; // no channel tags, ignore any array passed in
    noTags = (chan == null) && (evt == null);
    if (proc && noTags && (fSize >= 17)) {
      // Use faster "effective field size" when ignoring Event & Channel Tags
      fSize = (fSize <= 32)? 32 : 64;
    }
    switch (format) {
      case SignedInt:   // FALLTHROUGH
      case UnsignedInt:
        // ---- Try fast methods -------------------------------------------------
        if (noTags) {
          switch (fSize) {
            case  8: packBytes(  buf, off, array, 0, length, fSize, dSize, proc, sign); return;
            case 16: packShorts( buf, off, array, 0, length, fSize, dSize, proc, sign); return;
            case 24: packInt24s( buf, off, array, 0, length, fSize, dSize, proc, sign); return;
            case 32: packInts(   buf, off, array, 0, length, fSize, dSize, proc, sign); return;
            case 64: packLongs(  buf, off, array, 0, length, fSize, dSize, proc, sign); return;
          }
        }
        if (fSize == dSize) { // implicit noTags=true in this case
          switch (fSize) {
            case  1: if ((length % 8) == 0) { packBits(   buf, off, array, 0, length, fSize, dSize, proc, sign); return; } break;
            case  4: if ((length % 2) == 0) { packNibbles(buf, off, array, 0, length, fSize, dSize, proc, sign); return; } break;
            case 12: if ((length % 2) == 0) { packInt12s( buf, off, array, 0, length, fSize, dSize, proc, sign); return; } break;
          }
        }
        if ((proc && (fSize >= 17)) || (fSize == 32) || (fSize == 64)) {
          if (fSize <= 32) {
            packIntWord32(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
          }
          else {
            packIntWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
          }
        }
        // ---- Fall back to slow method -----------------------------------------
        if (fSize <= 32) {
          packIntBuffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packIntBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case Float:
        // ---- Try fast methods -------------------------------------------------
        if (fSize == dSize) { // implicit noTags=true in this case
          packFloats(buf, off, array, 0, length, fSize, dSize, proc, sign); return;
        }
        if ((proc && (fSize >= 33)) || (fSize == 64)) {
          packFloatWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        // ---- Fall back to slow method -----------------------------------------
        packFloatBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      case Double:
        // ---- Only fast method for double (yea!) -------------------------------
        packDoubles(buf, off, array, 0, length, fSize, dSize, proc, sign); return;
      case SignedVRT1:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packSignedVRT1Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packSignedVRT1Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case SignedVRT2:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packSignedVRT2Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packSignedVRT2Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case SignedVRT3:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packSignedVRT3Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packSignedVRT3Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case SignedVRT4:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packSignedVRT4Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packSignedVRT4Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case SignedVRT5:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packSignedVRT5Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packSignedVRT5Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case SignedVRT6:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packSignedVRT6Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packSignedVRT6Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case UnsignedVRT1:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packUnsignedVRT1Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packUnsignedVRT1Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case UnsignedVRT2:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packUnsignedVRT2Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packUnsignedVRT2Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case UnsignedVRT3:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packUnsignedVRT3Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packUnsignedVRT3Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case UnsignedVRT4:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packUnsignedVRT4Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packUnsignedVRT4Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case UnsignedVRT5:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packUnsignedVRT5Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packUnsignedVRT5Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case UnsignedVRT6:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packUnsignedVRT6Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packUnsignedVRT6Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      default:
        throw new UnsupportedOperationException("Packing of VRT float types not supported yet");
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for double data.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits (must be 64)
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed? (must be true)
   */
  @SuppressWarnings("cast")
  private static  void unpackDoubles (byte[] buf, int off, float[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    // All floating-point values are signed, so 'sign' is unused, but is included
    // in function definition for consistency.
    // When using Double data, it is required that dSize=64 and fSize=64 so we can
    // skip some of the normal checks we would otherwise do here.
    for (int i = 0; i < length; i++,off+=8) {
      array[offset++] = (float)unpackDouble(buf, off);
    }
  }
  /** <b>Internal Use Only:</b>
   *  Fast pack method for double data.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits (must be 64)
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed? (must be true)
   */
  @SuppressWarnings("cast")
  private static  void packDoubles (byte[] buf, int off, float[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    // All floating-point values are signed, so 'sign' is unused, but is included
    // in function definition for consistency.
    // When using Double data, it is required that dSize=64 and fSize=64 so we can
    // skip some of the normal checks we would otherwise do here.
    for (int i = 0; i < length; i++,off+=8) {
      packDouble(buf, off, (double)array[offset++]);
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for float data.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits (must be 32)
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed? (must be true)
   */
  @SuppressWarnings("cast")
  private static  void unpackFloats (byte[] buf, int off, float[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    // All floating-point values are signed, so 'sign' is unused, but is included
    // in function definition for consistency.
    int delta; // byte offset delta
    if (align) delta = (fSize <= 32)? 4 : 8;
    else       delta = fSize / 8;
    for (int i = 0; i < length; i++,off+=delta) {
      array[offset++] = (float)unpackFloat(buf, off);
    }
  }
  /** <b>Internal Use Only:</b>
   *  Fast pack method for float data.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits (must be 32)
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed? (must be true)
   */
  @SuppressWarnings("cast")
  private static  void packFloats (byte[] buf, int off, float[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    // All floating-point values are signed, so 'sign' is unused, but is included
    // in function definition for consistency.
    int delta; // byte offset delta
    if (align) delta = (fSize <= 32)? 4 : 8;
    else       delta = fSize / 8;
    if (delta == 4) {
      for (int i = 0; i < length; i++,off+=4) {
        packFloat(buf, off, (float)array[offset++]);
      }
    }
    else {
      for (int i = 0; i < length; i++) {
        packFloat(buf, off, (float)array[offset++]);
        off += 4;
        for (int j = 4; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for signed long data.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void unpackLongs (byte[] buf, int off, float[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // byte offset delta
    if (sign) {
      if (dSize == 64) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (float)unpackLong(buf, off);
        }
      }
      else {
        int shift  = 64 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (float)(unpackLong(buf, off) >> shift);
        }
      }
    }
    else {
      if (dSize == 64) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (float)(unpackLong(buf, off) & 0xFFFFFFFFFFFFFFFFL);
        }
      }
      else {
        int shift  = 64 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (float)((unpackLong(buf, off) & 0xFFFFFFFFFFFFFFFFL) >>> shift);
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast pack method for unsigned long data.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void packLongs (byte[] buf, int off, float[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // byte offset delta
    long valMask = (sign)? ((long)-1) : ((long)0xFFFFFFFFL); // Bit mask for input value (controls sign-extend)
    if (dSize == 64) {
      if (delta == 8) {
        for (int i = 0; i < length; i++,off+=8) {
          long val = (long)(((long)array[offset++]) & valMask);
          packLong(buf, off, val);
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          long val = (long)(((long)array[offset++]) & valMask);
          packLong(buf, off, val);
          off += 8;
          for (int j = 8; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
    else {
      int shift = 64 - dSize;
      if (delta == 8) {
        for (int i = 0; i < length; i++,off+=8) {
          long val = (long)(((long)array[offset++]) & valMask);
          packLong(buf, off, (long)(val << shift));
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          long val = (long)(((long)array[offset++]) & valMask);
          packLong(buf, off, (long)(val << shift));
          off += 8;
          for (int j = 8; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for signed int data.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void unpackInts (byte[] buf, int off, float[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // byte offset delta
    if (sign) {
      if (dSize == 32) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (float)unpackInt(buf, off);
        }
      }
      else {
        int shift  = 32 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (float)(unpackInt(buf, off) >> shift);
        }
      }
    }
    else {
      if (dSize == 32) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (float)(unpackInt(buf, off) & 0xFFFFFFFFL);
        }
      }
      else {
        int shift  = 32 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (float)((unpackInt(buf, off) & 0xFFFFFFFFL) >>> shift);
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast pack method for unsigned int data.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void packInts (byte[] buf, int off, float[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // byte offset delta
    int valMask = (sign)? ((int)-1) : ((int)0xFFFFFFFFL); // Bit mask for input value (controls sign-extend)
    if (dSize == 32) {
      if (delta == 4) {
        for (int i = 0; i < length; i++,off+=4) {
          int val = (int)(((int)array[offset++]) & valMask);
          packInt(buf, off, val);
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          int val = (int)(((int)array[offset++]) & valMask);
          packInt(buf, off, val);
          off += 4;
          for (int j = 4; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
    else {
      int shift = 32 - dSize;
      if (delta == 4) {
        for (int i = 0; i < length; i++,off+=4) {
          int val = (int)(((int)array[offset++]) & valMask);
          packInt(buf, off, (int)(val << shift));
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          int val = (int)(((int)array[offset++]) & valMask);
          packInt(buf, off, (int)(val << shift));
          off += 4;
          for (int j = 4; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for signed int data.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void unpackInt24s (byte[] buf, int off, float[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // byte offset delta
    if (sign) {
      if (dSize == 24) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (float)unpackInt24(buf, off);
        }
      }
      else {
        int shift  = 24 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (float)(unpackInt24(buf, off) >> shift);
        }
      }
    }
    else {
      if (dSize == 24) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (float)(unpackInt24(buf, off) & 0xFFFFFFL);
        }
      }
      else {
        int shift  = 24 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (float)((unpackInt24(buf, off) & 0xFFFFFFL) >>> shift);
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast pack method for unsigned int data.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void packInt24s (byte[] buf, int off, float[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // byte offset delta
    int valMask = (sign)? ((int)-1) : ((int)0xFFFFFFFFL); // Bit mask for input value (controls sign-extend)
    if (dSize == 24) {
      if (delta == 3) {
        for (int i = 0; i < length; i++,off+=3) {
          int val = (int)(((int)array[offset++]) & valMask);
          packInt24(buf, off, val);
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          int val = (int)(((int)array[offset++]) & valMask);
          packInt24(buf, off, val);
          off += 3;
          for (int j = 3; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
    else {
      int shift = 24 - dSize;
      if (delta == 3) {
        for (int i = 0; i < length; i++,off+=3) {
          int val = (int)(((int)array[offset++]) & valMask);
          packInt24(buf, off, (int)(val << shift));
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          int val = (int)(((int)array[offset++]) & valMask);
          packInt24(buf, off, (int)(val << shift));
          off += 3;
          for (int j = 3; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for signed short data.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void unpackShorts (byte[] buf, int off, float[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = fSize / 8; // byte offset delta
    if (sign) {
      if (dSize == 16) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (float)unpackShort(buf, off);
        }
      }
      else {
        int shift  = 16 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (float)(unpackShort(buf, off) >> shift);
        }
      }
    }
    else {
      if (dSize == 16) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (float)(unpackShort(buf, off) & 0xFFFFL);
        }
      }
      else {
        int shift  = 16 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (float)((unpackShort(buf, off) & 0xFFFFL) >>> shift);
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast pack method for unsigned short data.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void packShorts (byte[] buf, int off, float[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = fSize / 8; // byte offset delta
    short valMask = (sign)? ((short)-1) : ((short)0xFFFFFFFFL); // Bit mask for input value (controls sign-extend)
    if (dSize == 16) {
      if (delta == 2) {
        for (int i = 0; i < length; i++,off+=2) {
          short val = (short)(((short)array[offset++]) & valMask);
          packShort(buf, off, val);
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          short val = (short)(((short)array[offset++]) & valMask);
          packShort(buf, off, val);
          off += 2;
          for (int j = 2; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
    else {
      int shift = 16 - dSize;
      if (delta == 2) {
        for (int i = 0; i < length; i++,off+=2) {
          short val = (short)(((short)array[offset++]) & valMask);
          packShort(buf, off, (short)(val << shift));
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          short val = (short)(((short)array[offset++]) & valMask);
          packShort(buf, off, (short)(val << shift));
          off += 2;
          for (int j = 2; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for signed Int12 data.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
   *  @param fSize  (IN)  Item packing field size in bits (must be 12)
   *  @param dSize  (IN)  Data item size in bits (must be 12)
   *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackInt12s (byte[] buf, int off, float[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int skip = (align)? 1 : 0;
    if (sign) {
      for (int i = 0; i < length; i+=2) {
        int a = (int)buf[off++];
        int b = (int)buf[off++];
        int c = (int)buf[off++];
        int x = (a << 4) | ((b >> 4) & 0x000F);
        int y = (b << 8) | ((c     ) & 0x00FF);
        array[offset++] = (float)((x << 20) >> 20); // sign extend
        array[offset++] = (float)((y << 20) >> 20); // sign extend
        off += skip; // skip extra byte in processing-efficient mode
      }
    }
    else {
      for (int i = 0; i < length; i+=2) {
        int a = (int)buf[off++];
        int b = (int)buf[off++];
        int c = (int)buf[off++];
        int x = (a << 4) | ((b >> 4) & 0x000F);
        int y = (b << 8) | ((c     ) & 0x00FF);
        array[offset++] = (float)(x & 0x0FFF); // clear high-order bits
        array[offset++] = (float)(y & 0x0FFF); // clear high-order bits
        off += skip; // skip extra byte in processing-efficient mode
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast pack method for signed Int12 data.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
   *  @param fSize  (IN)  Item packing field size in bits (must be 12)
   *  @param dSize  (IN)  Data item size in bits (must be 12)
   *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packInt12s (byte[] buf, int off, float[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int skip = (align)?  1 : 0;
    int mask = (sign )? -1 : ((int)0xFFFFFFFFL);
    for (int i = 0; i < length; i+=2) {
      int first  = ((int)array[offset++]) & mask;
      int second = ((int)array[offset++]) & mask;
      buf[off++] = (byte)(first >> 4);
      buf[off++] = (byte)((first << 4) | ((second >> 8) & 0x0F));
      buf[off++] = (byte)(second);
      off += skip; // skip extra byte in processing-efficient mode
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for signed byte data.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void unpackBytes (byte[] buf, int off, float[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = fSize / 8; // byte offset delta
    if (sign) {
      if (dSize == 8) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (float)unpackByte(buf, off);
        }
      }
      else {
        int shift  = 8 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (float)(unpackByte(buf, off) >> shift);
        }
      }
    }
    else {
      if (dSize == 8) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (float)(unpackByte(buf, off) & 0xFFL);
        }
      }
      else {
        int shift  = 8 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (float)((unpackByte(buf, off) & 0xFFL) >>> shift);
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast pack method for unsigned byte data.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void packBytes (byte[] buf, int off, float[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = fSize / 8; // byte offset delta
    byte valMask = (sign)? ((byte)-1) : ((byte)0xFFFFFFFFL); // Bit mask for input value (controls sign-extend)
    if (dSize == 8) {
      if (delta == 1) {
        for (int i = 0; i < length; i++,off+=1) {
          byte val = (byte)(((byte)array[offset++]) & valMask);
          packByte(buf, off, val);
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          byte val = (byte)(((byte)array[offset++]) & valMask);
          packByte(buf, off, val);
          off += 1;
          for (int j = 1; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
    else {
      int shift = 8 - dSize;
      if (delta == 1) {
        for (int i = 0; i < length; i++,off+=1) {
          byte val = (byte)(((byte)array[offset++]) & valMask);
          packByte(buf, off, (byte)(val << shift));
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          byte val = (byte)(((byte)array[offset++]) & valMask);
          packByte(buf, off, (byte)(val << shift));
          off += 1;
          for (int j = 1; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for signed Int4 (nibble) data.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
   *  @param fSize  (IN)  Item packing field size in bits (must be 4)
   *  @param dSize  (IN)  Data item size in bits (must be 4)
   *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackNibbles (byte[] buf, int off, float[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    if (sign) {
      for (int i = 0; i < length; i+=2) {
        int b = (int)buf[off++];
        array[offset++] = (float)((b << 24) >> 28); // shift & sign extend
        array[offset++] = (float)((b << 28) >> 28); // shift & sign extend
      }
    }
    else {
      for (int i = 0; i < length; i+=2) {
        int b = (int)buf[off++];
        array[offset++] = (float)((b >> 4) & 0xF);
        array[offset++] = (float)((b     ) & 0xF);
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast pack method for signed Int4 (nibble) data.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
   *  @param fSize  (IN)  Item packing field size in bits (must be 4)
   *  @param dSize  (IN)  Data item size in bits (must be 4)
   *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packNibbles (byte[] buf, int off, float[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    // Pack function for signed and are identical for nibble data, hence
    // 'sign' is unused here, but included in function definition for consistency.
    for (int i = 0; i < length; i+=2) {
      int first  = (int)array[offset++];
      int second = (int)array[offset++];
      buf[off++] = (byte)((first << 4) | (second & 0xF));
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for bit data. Each bit in the
   *  input buffer will be checked, a 0 bit will correspond to the value 0 and a
   *  1 bit will correspond to the value 1.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert (must be a multiple of 8)
   *  @param fSize  (IN)  Item packing field size in bits (must be 1)
   *  @param dSize  (IN)  Data item size in bits (must be 1)
   *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackBits (byte[] buf, int off, float[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    if (sign) {
      // This uses sign-extending principles to get each bit as 0 or -1 which reflects
      // the fact that 0/-1 and not 0/+1 are the available values in a one-bit use of
      // twos-complement.
      for (int i = 0; i < length; i+=8) {
        int b = (int)buf[off++];
        array[offset++] = (float)((b << 24) >> 31);
        array[offset++] = (float)((b << 25) >> 31);
        array[offset++] = (float)((b << 26) >> 31);
        array[offset++] = (float)((b << 27) >> 31);
        array[offset++] = (float)((b << 28) >> 31);
        array[offset++] = (float)((b << 29) >> 31);
        array[offset++] = (float)((b << 30) >> 31);
        array[offset++] = (float)((b << 31) >> 31);
      }
    }
    else {
      for (int i = 0; i < length; i+=8) {
        int b = (int)buf[off++];
        array[offset++] = (float)((b >> 7) & 0x1);
        array[offset++] = (float)((b >> 6) & 0x1);
        array[offset++] = (float)((b >> 5) & 0x1);
        array[offset++] = (float)((b >> 4) & 0x1);
        array[offset++] = (float)((b >> 3) & 0x1);
        array[offset++] = (float)((b >> 2) & 0x1);
        array[offset++] = (float)((b >> 1) & 0x1);
        array[offset++] = (float)((b     ) & 0x1);
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast pack method for bit data. Each value in the
   *  input array will be checked, a zero value will correspond to the bit 0 and
   *  any non-zero value will correspond to the bit 1.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert (must be a multiple of 8)
   *  @param fSize  (IN)  Item packing field size in bits (must be 1)
   *  @param dSize  (IN)  Data item size in bits (must be 1)
   *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packBits (byte[] buf, int off, float[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    // Pack function for signed and are identical for bit data, hence
    // 'sign' is unused here, but included in function definition for consistency.
    for (int i = 0; i < length; i+=8) {
      int b = 0;
      b |= (((long)array[offset++]) << 7) & 0x80;
      b |= (((long)array[offset++]) << 6) & 0x40;
      b |= (((long)array[offset++]) << 5) & 0x20;
      b |= (((long)array[offset++]) << 4) & 0x10;
      b |= (((long)array[offset++]) << 3) & 0x08;
      b |= (((long)array[offset++]) << 2) & 0x04;
      b |= (((long)array[offset++]) << 1) & 0x02;
      b |= (((long)array[offset++])     ) & 0x01;
      buf[off++] = (byte)b;
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array, where the data is
   *  aligned to 32-bit word boundaries.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array  (OUT) Output value array (not null)
   *  @param chan   (OUT) Output channel tag array (null if n/a)
   *  @param evt    (OUT) Output event tag array (null if n/a)
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits
   *  @param dSize  (IN)  Data item size in bits
   *  @param eSize  (IN)  Event tag size in bits
   *  @param cSize  (IN)  Channel tag size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackIntWord32 (byte[] buf, int off, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+- - - - - +
    //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
    //   +-----------+--------+-----------+-------------+- - - - - +
    //       dSize      uSize     eSize       cSize        pSize
    //   |------------------ fSize ---------------------|
    //   |---------------------- Word Size ------------------------|
    int    pSize    = 32 - fSize;
    int    evtMask  = ~(((int)-1) << eSize);
    int    chanMask = ~(((int)-1) << cSize);
    int valMask  = (sign)? ((int)-1) : (~(((int)-1) << dSize));
    for (int i = 0; i < length; i++,off+=4) {
      int value = unpackInt(buf, off);
      array[i] = (float)((value >> (32-dSize)) & valMask);
      if (chan != null) chan[i] = (value >> (pSize      )) & chanMask;
      if (evt  != null) evt[i]  = (value >> (pSize+cSize)) & evtMask;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array, where the data is
   *  aligned to 32-bit word boundaries.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input value array
   *  @param chan   (IN)  Input channel tag array (null if n/a)
   *  @param evt    (IN)  Input event tag array (null if n/a)
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits
   *  @param dSize  (IN)  Data item size in bits
   *  @param eSize  (IN)  Event tag size in bits
   *  @param cSize  (IN)  Channel tag size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packIntWord32 (byte[] buf, int off, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+- - - - - +
    //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
    //   +-----------+--------+-----------+-------------+- - - - - +
    //       dSize      uSize     eSize       cSize        pSize
    //   |------------------ fSize ---------------------|
    //   |---------------------- Word Size ------------------------|
    int    pSize    = 32 - fSize;
    int    evtMask  = ~(((int)-1) << eSize);
    int    chanMask = ~(((int)-1) << cSize);
    int valMask  = (sign)? ((int)-1) : ((int)0xFFFFFFFFL);
    for (int i = 0; i < length; i++,off+=4) {
      int val   = (int)(((int)array[i]) & valMask);
      int value = val << (32-dSize);
      if (chan != null) value |= (chan[i] & chanMask) << (pSize);
      if (evt  != null) value |= (evt[i]  & evtMask ) << (pSize+cSize);
      packInt(buf, off, value);
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array, where the data is
   *  aligned to 64-bit word boundaries.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array  (OUT) Output value array (not null)
   *  @param chan   (OUT) Output channel tag array (null if n/a)
   *  @param evt    (OUT) Output event tag array (null if n/a)
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits
   *  @param dSize  (IN)  Data item size in bits
   *  @param eSize  (IN)  Event tag size in bits
   *  @param cSize  (IN)  Channel tag size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackIntWord64 (byte[] buf, int off, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+- - - - - +
    //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
    //   +-----------+--------+-----------+-------------+- - - - - +
    //       dSize      uSize     eSize       cSize        pSize
    //   |------------------ fSize ---------------------|
    //   |---------------------- Word Size ------------------------|
    int    pSize    = 64 - fSize;
    int    evtMask  = ~(((int)-1) << eSize);
    int    chanMask = ~(((int)-1) << cSize);
    long valMask  = (sign)? ((long)-1) : (~(((long)-1) << dSize));
    if (dSize == 32) {
      // When using Int32/UInt32 the first 32-bits will always the the Int32/UInt32
      // value, so use 32-bit operations to improve performance
      for (int i = 0; i < length; i++,off+=8) {
        int val   = unpackInt(buf, off);
        int value = unpackInt(buf, off+4);
        array[i] = (float)(val & valMask);
        if (chan != null) chan[i] = ((int)(value >> (pSize      ))) & chanMask;
        if (evt  != null) evt[i]  = ((int)(value >> (pSize+cSize))) & evtMask;
      }
    }
    else {
      for (int i = 0; i < length; i++,off+=8) {
        long value = unpackLong(buf, off);
        array[i] = (float)((value >> (64-dSize)) & valMask);
        if (chan != null) chan[i] = ((int)(value >> (pSize      ))) & chanMask;
        if (evt  != null) evt[i]  = ((int)(value >> (pSize+cSize))) & evtMask;
      }
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array, where the data is
   *  aligned to 64-bit word boundaries.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input value array
   *  @param chan   (IN)  Input channel tag array (null if n/a)
   *  @param evt    (IN)  Input event tag array (null if n/a)
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits
   *  @param dSize  (IN)  Data item size in bits
   *  @param eSize  (IN)  Event tag size in bits
   *  @param cSize  (IN)  Channel tag size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packIntWord64 (byte[] buf, int off, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+- - - - - +
    //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
    //   +-----------+--------+-----------+-------------+- - - - - +
    //       dSize      uSize     eSize       cSize        pSize
    //   |------------------ fSize ---------------------|
    //   |---------------------- Word Size ------------------------|
    int    pSize    = 64 - fSize;
    int    evtMask  = ~(((int)-1) << eSize);
    int    chanMask = ~(((int)-1) << cSize);
    long valMask  = (sign)? ((long)-1) : ((long)0xFFFFFFFFL);
    if (dSize == 32) {
      // When using Int32/UInt32 the first 32-bits will always the the Int32/UInt32
      // value, so use 32-bit operations to improve performance
      for (int i = 0; i < length; i++,off+=8) {
        int val   = (int)(((long)array[i]) & valMask);
        int value = 0;
        if (chan != null) value  = (chan[i] & chanMask) << (pSize);
        if (evt  != null) value |= (evt[i]  & evtMask ) << (pSize+cSize);
        packInt(buf, off,   val);
        packInt(buf, off+4, value);
      }
    }
    else {
      for (int i = 0; i < length; i++,off+=8) {
        long val   = (long)(((long)array[i]) & valMask);
        long value = val << (64-dSize);
        if (chan != null) value |= ((long)(chan[i] & chanMask)) << (pSize);
        if (evt  != null) value |= ((long)(evt[i]  & evtMask )) << (pSize+cSize);
        packLong(buf, off, value);
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array, where the data is
   *  aligned to 64-bit word boundaries.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array  (OUT) Output value array (not null)
   *  @param chan   (OUT) Output channel tag array (null if n/a)
   *  @param evt    (OUT) Output event tag array (null if n/a)
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits
   *  @param dSize  (IN)  Data item size in bits
   *  @param eSize  (IN)  Event tag size in bits
   *  @param cSize  (IN)  Channel tag size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackFloatWord64 (byte[] buf, int off, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+- - - - - +
    //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
    //   +-----------+--------+-----------+-------------+- - - - - +
    //       dSize      uSize     eSize       cSize        pSize
    //   |------------------ fSize ---------------------|
    //   |---------------------- Word Size ------------------------|
    int    pSize    = 64 - fSize;
    int    evtMask  = ~(((int)-1) << eSize);
    int    chanMask = ~(((int)-1) << cSize);
    // When using Float32 the first 32-bits will always the the Float32 value, so
    // use 32-bit operations to improve performance
    for (int i = 0; i < length; i++,off+=8) {
      array[i] = (float)unpackFloat(buf, off);
      int value = unpackInt(buf, off+4);
      if (chan != null) chan[i] = (value >> (pSize      )) & chanMask;
      if (evt  != null) evt[i]  = (value >> (pSize+cSize)) & evtMask;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array, where the data is
   *  aligned to 64-bit word boundaries.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input value array
   *  @param chan   (IN)  Input channel tag array (null if n/a)
   *  @param evt    (IN)  Input event tag array (null if n/a)
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits
   *  @param dSize  (IN)  Data item size in bits
   *  @param eSize  (IN)  Event tag size in bits
   *  @param cSize  (IN)  Channel tag size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packFloatWord64 (byte[] buf, int off, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+- - - - - +
    //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
    //   +-----------+--------+-----------+-------------+- - - - - +
    //       dSize      uSize     eSize       cSize        pSize
    //   |------------------ fSize ---------------------|
    //   |---------------------- Word Size ------------------------|
    int    pSize    = 64 - fSize;
    int    evtMask  = ~(((int)-1) << eSize);
    int    chanMask = ~(((int)-1) << cSize);
    // When using Float32 the first 32-bits will always the the Float32 value, so
    // use 32-bit operations to improve performance
    for (int i = 0; i < length; i++,off+=8) {
      float val   = (float)array[i];
      int   value = 0;
      if (chan != null) value  = (chan[i] & chanMask) << (pSize);
      if (evt  != null) value |= (evt[i]  & evtMask ) << (pSize+cSize);
      packFloat(buf, off,   val);
      packInt(  buf, off+4, value);
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackIntBuffer32 (byte[] buf, int bitOffset, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_dSize  = 32 - dSize;    // pre-compute "32 - dSize" for efficiency
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        if (sign) {
          // sign extend
          array[offset] = (float)((value << _bits_dSize) >>  _bits_dSize);
        }
        else {
          // leave top bits (which default to 0) as 0
          array[offset] = (float)value;
        }
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packIntBuffer32 (byte[] buf, int bitOffset, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    int valMask      = (sign)? ((int)-1) : ((int)0xFFFFFFFFL); // Bit mask for input value (controls sign-extend)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        int arrayValue = ((int)array[offset]) & valMask;
        int value      = (int)((arrayValue) << (32 - dSize));
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackIntBuffer64 (byte[] buf, int bitOffset, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_dSize  = 64 - dSize;    // pre-compute "64 - dSize" for efficiency
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        if (sign) {
          // sign extend
          array[offset] = (float)((value << _bits_dSize) >>  _bits_dSize);
        }
        else {
          // leave top bits (which default to 0) as 0
          array[offset] = (float)value;
        }
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packIntBuffer64 (byte[] buf, int bitOffset, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    long valMask      = (sign)? ((long)-1) : ((long)0xFFFFFFFFL); // Bit mask for input value (controls sign-extend)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        long arrayValue = ((long)array[offset]) & valMask;
        long value      = (long)((arrayValue) << (64 - dSize));
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackFloatBuffer64 (byte[] buf, int bitOffset, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (float)intBitsToFloat((int)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packFloatBuffer64 (byte[] buf, int bitOffset, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        float  arrayValue = (float)array[offset];
        long   value      = ((long)floatToRawIntBits(arrayValue)) << 32;
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT1Buffer32 (byte[] buf, int bitOffset, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (float)fromVRTFloat(DataItemFormat.SignedVRT1, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT1Buffer32 (byte[] buf, int bitOffset, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.SignedVRT1, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT1Buffer64 (byte[] buf, int bitOffset, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (float)fromVRTFloat(DataItemFormat.SignedVRT1, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT1Buffer64 (byte[] buf, int bitOffset, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.SignedVRT1, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT2Buffer32 (byte[] buf, int bitOffset, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (float)fromVRTFloat(DataItemFormat.SignedVRT2, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT2Buffer32 (byte[] buf, int bitOffset, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.SignedVRT2, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT2Buffer64 (byte[] buf, int bitOffset, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (float)fromVRTFloat(DataItemFormat.SignedVRT2, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT2Buffer64 (byte[] buf, int bitOffset, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.SignedVRT2, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT3Buffer32 (byte[] buf, int bitOffset, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (float)fromVRTFloat(DataItemFormat.SignedVRT3, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT3Buffer32 (byte[] buf, int bitOffset, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.SignedVRT3, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT3Buffer64 (byte[] buf, int bitOffset, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (float)fromVRTFloat(DataItemFormat.SignedVRT3, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT3Buffer64 (byte[] buf, int bitOffset, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.SignedVRT3, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT4Buffer32 (byte[] buf, int bitOffset, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (float)fromVRTFloat(DataItemFormat.SignedVRT4, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT4Buffer32 (byte[] buf, int bitOffset, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.SignedVRT4, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT4Buffer64 (byte[] buf, int bitOffset, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (float)fromVRTFloat(DataItemFormat.SignedVRT4, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT4Buffer64 (byte[] buf, int bitOffset, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.SignedVRT4, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT5Buffer32 (byte[] buf, int bitOffset, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (float)fromVRTFloat(DataItemFormat.SignedVRT5, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT5Buffer32 (byte[] buf, int bitOffset, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.SignedVRT5, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT5Buffer64 (byte[] buf, int bitOffset, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (float)fromVRTFloat(DataItemFormat.SignedVRT5, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT5Buffer64 (byte[] buf, int bitOffset, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.SignedVRT5, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT6Buffer32 (byte[] buf, int bitOffset, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (float)fromVRTFloat(DataItemFormat.SignedVRT6, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT6Buffer32 (byte[] buf, int bitOffset, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.SignedVRT6, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT6Buffer64 (byte[] buf, int bitOffset, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (float)fromVRTFloat(DataItemFormat.SignedVRT6, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT6Buffer64 (byte[] buf, int bitOffset, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.SignedVRT6, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT1Buffer32 (byte[] buf, int bitOffset, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (float)fromVRTFloat(DataItemFormat.UnsignedVRT1, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT1Buffer32 (byte[] buf, int bitOffset, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.UnsignedVRT1, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT1Buffer64 (byte[] buf, int bitOffset, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (float)fromVRTFloat(DataItemFormat.UnsignedVRT1, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT1Buffer64 (byte[] buf, int bitOffset, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.UnsignedVRT1, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT2Buffer32 (byte[] buf, int bitOffset, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (float)fromVRTFloat(DataItemFormat.UnsignedVRT2, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT2Buffer32 (byte[] buf, int bitOffset, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.UnsignedVRT2, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT2Buffer64 (byte[] buf, int bitOffset, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (float)fromVRTFloat(DataItemFormat.UnsignedVRT2, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT2Buffer64 (byte[] buf, int bitOffset, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.UnsignedVRT2, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT3Buffer32 (byte[] buf, int bitOffset, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (float)fromVRTFloat(DataItemFormat.UnsignedVRT3, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT3Buffer32 (byte[] buf, int bitOffset, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.UnsignedVRT3, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT3Buffer64 (byte[] buf, int bitOffset, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (float)fromVRTFloat(DataItemFormat.UnsignedVRT3, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT3Buffer64 (byte[] buf, int bitOffset, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.UnsignedVRT3, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT4Buffer32 (byte[] buf, int bitOffset, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (float)fromVRTFloat(DataItemFormat.UnsignedVRT4, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT4Buffer32 (byte[] buf, int bitOffset, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.UnsignedVRT4, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT4Buffer64 (byte[] buf, int bitOffset, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (float)fromVRTFloat(DataItemFormat.UnsignedVRT4, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT4Buffer64 (byte[] buf, int bitOffset, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.UnsignedVRT4, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT5Buffer32 (byte[] buf, int bitOffset, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (float)fromVRTFloat(DataItemFormat.UnsignedVRT5, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT5Buffer32 (byte[] buf, int bitOffset, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.UnsignedVRT5, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT5Buffer64 (byte[] buf, int bitOffset, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (float)fromVRTFloat(DataItemFormat.UnsignedVRT5, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT5Buffer64 (byte[] buf, int bitOffset, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.UnsignedVRT5, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT6Buffer32 (byte[] buf, int bitOffset, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (float)fromVRTFloat(DataItemFormat.UnsignedVRT6, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT6Buffer32 (byte[] buf, int bitOffset, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.UnsignedVRT6, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT6Buffer64 (byte[] buf, int bitOffset, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (float)fromVRTFloat(DataItemFormat.UnsignedVRT6, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT6Buffer64 (byte[] buf, int bitOffset, float[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.UnsignedVRT6, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Unpacks values with the given format specifier as
   *  an array of <tt>float</tt>. <br>
   *  <br>
   *  Setting the channel tags (<tt>chan</tt>) and/or event tags (<tt>evt</tt>)
   *  arrays to null will cause any channel or event tags present to be ignored.
   *  In most cases this results in a performance improvement. <br>
   *  <br>
   *  If the channel tags (<tt>chan</tt>) and/or event tags (<tt>evt</tt>) arrays
   *  are non-null when there are no channel or event tags present, the values in
   *  the arrays will not be modified.
   *  @param pf     (IN)  The data format
   *  @param buf    (IN)  The buffer
   *  @param off    (IN)  The buffer offset
   *  @param array  (OUT) The output array for the values
   *  @param chan   (OUT) The output array for the channel tags (null if n/a)
   *  @param evt    (OUT) The output array for the event tags (null if n/a)
   *  @param length (IN)  Number of elements to convert
   *  @return The output array (same as <tt>array</tt>).
   */
  @SuppressWarnings("fallthrough")
  public static float[] unpackAsFloat (PayloadFormat pf, byte[] buf, int off, float[] array, int[] chan, int[] evt, int length) {
    if (!pf.isValid()) {
      throw new IllegalArgumentException(pf.getValid());
    }
    int            fSize  = pf.getItemPackingFieldSize();
    int            dSize  = pf.getDataItemSize();
    int            eSize  = pf.getEventTagSize();
    int            cSize  = pf.getChannelTagSize();
    boolean        proc   = pf.isProcessingEfficient();
    boolean        sign   = pf.isSigned();
    DataItemFormat format = pf.getDataItemFormat();
    boolean        noTags;
    if (eSize == 0) evt  = null; // no event tags, ignore any array passed in
    if (cSize == 0) chan = null; // no channel tags, ignore any array passed in
    noTags = (chan == null) && (evt == null);
    if (proc && noTags && (fSize >= 17)) {
      // Use faster "effective field size" when ignoring Event & Channel Tags
      fSize = (fSize <= 32)? 32 : 64;
    }
    switch (format) {
      case SignedInt:   // FALLTHROUGH
      case UnsignedInt:
        // ---- Try fast methods -------------------------------------------------
        if (noTags) {
          switch (fSize) {
            case  8: unpackBytes(  buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
            case 16: unpackShorts( buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
            case 24: unpackInt24s( buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
            case 32: unpackInts(   buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
            case 64: unpackLongs(  buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
          }
        }
        if (fSize == dSize) { // implicit noTags=true in this case
          switch (fSize) {
            case  1: if ((length % 8) == 0) { unpackBits(   buf, off, array, 0, length, fSize, dSize, proc, sign); return array; } break;
            case  4: if ((length % 2) == 0) { unpackNibbles(buf, off, array, 0, length, fSize, dSize, proc, sign); return array; } break;
            case 12: if ((length % 2) == 0) { unpackInt12s( buf, off, array, 0, length, fSize, dSize, proc, sign); return array; } break;
          }
        }
        if ((proc && (fSize >= 17)) || (fSize == 32) || (fSize == 64)) {
          if (fSize <= 32) {
            unpackIntWord32(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
          }
          else {
            unpackIntWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
          }
        }
        // ---- Fall back to slow method -----------------------------------------
        if (fSize <= 32) {
          unpackIntBuffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackIntBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case Float:
        // ---- Try fast methods -------------------------------------------------
        if (fSize == dSize) { // implicit noTags=true in this case
          unpackFloats(buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
        }
        if ((proc && (fSize >= 33)) || (fSize == 64)) {
          unpackFloatWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        // ---- Fall back to slow method -----------------------------------------
        unpackFloatBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      case Double:
        // ---- Only fast method for double (yea!) -------------------------------
        unpackDoubles(buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
      case SignedVRT1:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackSignedVRT1Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackSignedVRT1Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case SignedVRT2:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackSignedVRT2Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackSignedVRT2Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case SignedVRT3:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackSignedVRT3Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackSignedVRT3Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case SignedVRT4:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackSignedVRT4Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackSignedVRT4Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case SignedVRT5:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackSignedVRT5Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackSignedVRT5Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case SignedVRT6:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackSignedVRT6Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackSignedVRT6Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case UnsignedVRT1:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackUnsignedVRT1Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackUnsignedVRT1Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case UnsignedVRT2:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackUnsignedVRT2Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackUnsignedVRT2Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case UnsignedVRT3:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackUnsignedVRT3Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackUnsignedVRT3Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case UnsignedVRT4:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackUnsignedVRT4Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackUnsignedVRT4Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case UnsignedVRT5:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackUnsignedVRT5Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackUnsignedVRT5Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case UnsignedVRT6:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackUnsignedVRT6Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackUnsignedVRT6Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      default:
        throw new UnsupportedOperationException("Unpacking of VRT float types not supported yet");
    }
  }
  /** <b>Internal Use Only:</b> Packs values with the given format specifier from
   *  an array of float. <br>
   *  <br>
   *  Setting the channel tags (<tt>chan</tt>) and/or event tags (<tt>evt</tt>)
   *  arrays to null will cause any channel or event tags present to be set to
   *  zero. In most cases this results in a performance improvement over passing
   *  in an array of zeros. <br>
   *  <br>
   *  If the channel tags (<tt>chan</tt>) and/or event tags (<tt>evt</tt>) arrays
   *  are non-null when there are no channel or event tags present, the values in
   *  the arrays will be ignored.
   *  @param pf     (IN)  The data format
   *  @param buf    (I/O) The buffer
   *  @param off    (IN)  The buffer offset
   *  @param array  (IN)  The values to pack
   *  @param chan   (OUT) The output array for the channel tags (null if n/a)
   *  @param evt    (OUT) The output array for the event tags (null if n/a)
   *  @param length (IN)  Number of elements to convert
   */
  @SuppressWarnings("fallthrough")
  public static void packAsFloat (PayloadFormat pf, byte[] buf, int off, float[] array, int[] chan, int[] evt, int length) {
    if (!pf.isValid()) {
      throw new IllegalArgumentException(pf.getValid());
    }
    int            fSize  = pf.getItemPackingFieldSize();
    int            dSize  = pf.getDataItemSize();
    int            eSize  = pf.getEventTagSize();
    int            cSize  = pf.getChannelTagSize();
    boolean        proc   = pf.isProcessingEfficient();
    boolean        sign   = pf.isSigned();
    DataItemFormat format = pf.getDataItemFormat();
    boolean        noTags;
    if (eSize == 0) evt  = null; // no event tags, ignore any array passed in
    if (cSize == 0) chan = null; // no channel tags, ignore any array passed in
    noTags = (chan == null) && (evt == null);
    if (proc && noTags && (fSize >= 17)) {
      // Use faster "effective field size" when ignoring Event & Channel Tags
      fSize = (fSize <= 32)? 32 : 64;
    }
    switch (format) {
      case SignedInt:   // FALLTHROUGH
      case UnsignedInt:
        // ---- Try fast methods -------------------------------------------------
        if (noTags) {
          switch (fSize) {
            case  8: packBytes(  buf, off, array, 0, length, fSize, dSize, proc, sign); return;
            case 16: packShorts( buf, off, array, 0, length, fSize, dSize, proc, sign); return;
            case 24: packInt24s( buf, off, array, 0, length, fSize, dSize, proc, sign); return;
            case 32: packInts(   buf, off, array, 0, length, fSize, dSize, proc, sign); return;
            case 64: packLongs(  buf, off, array, 0, length, fSize, dSize, proc, sign); return;
          }
        }
        if (fSize == dSize) { // implicit noTags=true in this case
          switch (fSize) {
            case  1: if ((length % 8) == 0) { packBits(   buf, off, array, 0, length, fSize, dSize, proc, sign); return; } break;
            case  4: if ((length % 2) == 0) { packNibbles(buf, off, array, 0, length, fSize, dSize, proc, sign); return; } break;
            case 12: if ((length % 2) == 0) { packInt12s( buf, off, array, 0, length, fSize, dSize, proc, sign); return; } break;
          }
        }
        if ((proc && (fSize >= 17)) || (fSize == 32) || (fSize == 64)) {
          if (fSize <= 32) {
            packIntWord32(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
          }
          else {
            packIntWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
          }
        }
        // ---- Fall back to slow method -----------------------------------------
        if (fSize <= 32) {
          packIntBuffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packIntBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case Float:
        // ---- Try fast methods -------------------------------------------------
        if (fSize == dSize) { // implicit noTags=true in this case
          packFloats(buf, off, array, 0, length, fSize, dSize, proc, sign); return;
        }
        if ((proc && (fSize >= 33)) || (fSize == 64)) {
          packFloatWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        // ---- Fall back to slow method -----------------------------------------
        packFloatBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      case Double:
        // ---- Only fast method for double (yea!) -------------------------------
        packDoubles(buf, off, array, 0, length, fSize, dSize, proc, sign); return;
      case SignedVRT1:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packSignedVRT1Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packSignedVRT1Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case SignedVRT2:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packSignedVRT2Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packSignedVRT2Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case SignedVRT3:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packSignedVRT3Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packSignedVRT3Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case SignedVRT4:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packSignedVRT4Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packSignedVRT4Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case SignedVRT5:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packSignedVRT5Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packSignedVRT5Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case SignedVRT6:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packSignedVRT6Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packSignedVRT6Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case UnsignedVRT1:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packUnsignedVRT1Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packUnsignedVRT1Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case UnsignedVRT2:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packUnsignedVRT2Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packUnsignedVRT2Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case UnsignedVRT3:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packUnsignedVRT3Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packUnsignedVRT3Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case UnsignedVRT4:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packUnsignedVRT4Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packUnsignedVRT4Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case UnsignedVRT5:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packUnsignedVRT5Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packUnsignedVRT5Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case UnsignedVRT6:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packUnsignedVRT6Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packUnsignedVRT6Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      default:
        throw new UnsupportedOperationException("Packing of VRT float types not supported yet");
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for double data.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits (must be 64)
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed? (must be true)
   */
  @SuppressWarnings("cast")
  private static  void unpackDoubles (byte[] buf, int off, long[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    // All floating-point values are signed, so 'sign' is unused, but is included
    // in function definition for consistency.
    // When using Double data, it is required that dSize=64 and fSize=64 so we can
    // skip some of the normal checks we would otherwise do here.
    for (int i = 0; i < length; i++,off+=8) {
      array[offset++] = (long)unpackDouble(buf, off);
    }
  }
  /** <b>Internal Use Only:</b>
   *  Fast pack method for double data.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits (must be 64)
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed? (must be true)
   */
  @SuppressWarnings("cast")
  private static  void packDoubles (byte[] buf, int off, long[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    // All floating-point values are signed, so 'sign' is unused, but is included
    // in function definition for consistency.
    // When using Double data, it is required that dSize=64 and fSize=64 so we can
    // skip some of the normal checks we would otherwise do here.
    for (int i = 0; i < length; i++,off+=8) {
      packDouble(buf, off, (double)array[offset++]);
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for float data.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits (must be 32)
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed? (must be true)
   */
  @SuppressWarnings("cast")
  private static  void unpackFloats (byte[] buf, int off, long[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    // All floating-point values are signed, so 'sign' is unused, but is included
    // in function definition for consistency.
    int delta; // byte offset delta
    if (align) delta = (fSize <= 32)? 4 : 8;
    else       delta = fSize / 8;
    for (int i = 0; i < length; i++,off+=delta) {
      array[offset++] = (long)unpackFloat(buf, off);
    }
  }
  /** <b>Internal Use Only:</b>
   *  Fast pack method for float data.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits (must be 32)
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed? (must be true)
   */
  @SuppressWarnings("cast")
  private static  void packFloats (byte[] buf, int off, long[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    // All floating-point values are signed, so 'sign' is unused, but is included
    // in function definition for consistency.
    int delta; // byte offset delta
    if (align) delta = (fSize <= 32)? 4 : 8;
    else       delta = fSize / 8;
    if (delta == 4) {
      for (int i = 0; i < length; i++,off+=4) {
        packFloat(buf, off, (float)array[offset++]);
      }
    }
    else {
      for (int i = 0; i < length; i++) {
        packFloat(buf, off, (float)array[offset++]);
        off += 4;
        for (int j = 4; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for signed long data.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void unpackLongs (byte[] buf, int off, long[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // byte offset delta
    if (sign) {
      if (dSize == 64) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (long)unpackLong(buf, off);
        }
      }
      else {
        int shift  = 64 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (long)(unpackLong(buf, off) >> shift);
        }
      }
    }
    else {
      if (dSize == 64) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (long)(unpackLong(buf, off) & 0xFFFFFFFFFFFFFFFFL);
        }
      }
      else {
        int shift  = 64 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (long)((unpackLong(buf, off) & 0xFFFFFFFFFFFFFFFFL) >>> shift);
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast pack method for unsigned long data.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void packLongs (byte[] buf, int off, long[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // byte offset delta
    long valMask = (sign)? ((long)-1) : ((long)0xFFFFFFFFFFFFFFFFL); // Bit mask for input value (controls sign-extend)
    if (dSize == 64) {
      if (delta == 8) {
        for (int i = 0; i < length; i++,off+=8) {
          long val = (long)(((long)array[offset++]) & valMask);
          packLong(buf, off, val);
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          long val = (long)(((long)array[offset++]) & valMask);
          packLong(buf, off, val);
          off += 8;
          for (int j = 8; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
    else {
      int shift = 64 - dSize;
      if (delta == 8) {
        for (int i = 0; i < length; i++,off+=8) {
          long val = (long)(((long)array[offset++]) & valMask);
          packLong(buf, off, (long)(val << shift));
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          long val = (long)(((long)array[offset++]) & valMask);
          packLong(buf, off, (long)(val << shift));
          off += 8;
          for (int j = 8; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for signed int data.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void unpackInts (byte[] buf, int off, long[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // byte offset delta
    if (sign) {
      if (dSize == 32) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (long)unpackInt(buf, off);
        }
      }
      else {
        int shift  = 32 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (long)(unpackInt(buf, off) >> shift);
        }
      }
    }
    else {
      if (dSize == 32) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (long)(unpackInt(buf, off) & 0xFFFFFFFFL);
        }
      }
      else {
        int shift  = 32 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (long)((unpackInt(buf, off) & 0xFFFFFFFFL) >>> shift);
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast pack method for unsigned int data.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void packInts (byte[] buf, int off, long[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // byte offset delta
    int valMask = (sign)? ((int)-1) : ((int)0xFFFFFFFFFFFFFFFFL); // Bit mask for input value (controls sign-extend)
    if (dSize == 32) {
      if (delta == 4) {
        for (int i = 0; i < length; i++,off+=4) {
          int val = (int)(((int)array[offset++]) & valMask);
          packInt(buf, off, val);
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          int val = (int)(((int)array[offset++]) & valMask);
          packInt(buf, off, val);
          off += 4;
          for (int j = 4; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
    else {
      int shift = 32 - dSize;
      if (delta == 4) {
        for (int i = 0; i < length; i++,off+=4) {
          int val = (int)(((int)array[offset++]) & valMask);
          packInt(buf, off, (int)(val << shift));
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          int val = (int)(((int)array[offset++]) & valMask);
          packInt(buf, off, (int)(val << shift));
          off += 4;
          for (int j = 4; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for signed int data.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void unpackInt24s (byte[] buf, int off, long[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // byte offset delta
    if (sign) {
      if (dSize == 24) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (long)unpackInt24(buf, off);
        }
      }
      else {
        int shift  = 24 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (long)(unpackInt24(buf, off) >> shift);
        }
      }
    }
    else {
      if (dSize == 24) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (long)(unpackInt24(buf, off) & 0xFFFFFFL);
        }
      }
      else {
        int shift  = 24 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (long)((unpackInt24(buf, off) & 0xFFFFFFL) >>> shift);
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast pack method for unsigned int data.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void packInt24s (byte[] buf, int off, long[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // byte offset delta
    int valMask = (sign)? ((int)-1) : ((int)0xFFFFFFFFFFFFFFFFL); // Bit mask for input value (controls sign-extend)
    if (dSize == 24) {
      if (delta == 3) {
        for (int i = 0; i < length; i++,off+=3) {
          int val = (int)(((int)array[offset++]) & valMask);
          packInt24(buf, off, val);
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          int val = (int)(((int)array[offset++]) & valMask);
          packInt24(buf, off, val);
          off += 3;
          for (int j = 3; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
    else {
      int shift = 24 - dSize;
      if (delta == 3) {
        for (int i = 0; i < length; i++,off+=3) {
          int val = (int)(((int)array[offset++]) & valMask);
          packInt24(buf, off, (int)(val << shift));
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          int val = (int)(((int)array[offset++]) & valMask);
          packInt24(buf, off, (int)(val << shift));
          off += 3;
          for (int j = 3; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for signed short data.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void unpackShorts (byte[] buf, int off, long[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = fSize / 8; // byte offset delta
    if (sign) {
      if (dSize == 16) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (long)unpackShort(buf, off);
        }
      }
      else {
        int shift  = 16 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (long)(unpackShort(buf, off) >> shift);
        }
      }
    }
    else {
      if (dSize == 16) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (long)(unpackShort(buf, off) & 0xFFFFL);
        }
      }
      else {
        int shift  = 16 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (long)((unpackShort(buf, off) & 0xFFFFL) >>> shift);
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast pack method for unsigned short data.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void packShorts (byte[] buf, int off, long[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = fSize / 8; // byte offset delta
    short valMask = (sign)? ((short)-1) : ((short)0xFFFFFFFFFFFFFFFFL); // Bit mask for input value (controls sign-extend)
    if (dSize == 16) {
      if (delta == 2) {
        for (int i = 0; i < length; i++,off+=2) {
          short val = (short)(((short)array[offset++]) & valMask);
          packShort(buf, off, val);
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          short val = (short)(((short)array[offset++]) & valMask);
          packShort(buf, off, val);
          off += 2;
          for (int j = 2; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
    else {
      int shift = 16 - dSize;
      if (delta == 2) {
        for (int i = 0; i < length; i++,off+=2) {
          short val = (short)(((short)array[offset++]) & valMask);
          packShort(buf, off, (short)(val << shift));
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          short val = (short)(((short)array[offset++]) & valMask);
          packShort(buf, off, (short)(val << shift));
          off += 2;
          for (int j = 2; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for signed Int12 data.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
   *  @param fSize  (IN)  Item packing field size in bits (must be 12)
   *  @param dSize  (IN)  Data item size in bits (must be 12)
   *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackInt12s (byte[] buf, int off, long[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int skip = (align)? 1 : 0;
    if (sign) {
      for (int i = 0; i < length; i+=2) {
        int a = (int)buf[off++];
        int b = (int)buf[off++];
        int c = (int)buf[off++];
        int x = (a << 4) | ((b >> 4) & 0x000F);
        int y = (b << 8) | ((c     ) & 0x00FF);
        array[offset++] = (long)((x << 20) >> 20); // sign extend
        array[offset++] = (long)((y << 20) >> 20); // sign extend
        off += skip; // skip extra byte in processing-efficient mode
      }
    }
    else {
      for (int i = 0; i < length; i+=2) {
        int a = (int)buf[off++];
        int b = (int)buf[off++];
        int c = (int)buf[off++];
        int x = (a << 4) | ((b >> 4) & 0x000F);
        int y = (b << 8) | ((c     ) & 0x00FF);
        array[offset++] = (long)(x & 0x0FFF); // clear high-order bits
        array[offset++] = (long)(y & 0x0FFF); // clear high-order bits
        off += skip; // skip extra byte in processing-efficient mode
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast pack method for signed Int12 data.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
   *  @param fSize  (IN)  Item packing field size in bits (must be 12)
   *  @param dSize  (IN)  Data item size in bits (must be 12)
   *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packInt12s (byte[] buf, int off, long[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int skip = (align)?  1 : 0;
    int mask = (sign )? -1 : ((int)0xFFFFFFFFFFFFFFFFL);
    for (int i = 0; i < length; i+=2) {
      int first  = ((int)array[offset++]) & mask;
      int second = ((int)array[offset++]) & mask;
      buf[off++] = (byte)(first >> 4);
      buf[off++] = (byte)((first << 4) | ((second >> 8) & 0x0F));
      buf[off++] = (byte)(second);
      off += skip; // skip extra byte in processing-efficient mode
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for signed byte data.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void unpackBytes (byte[] buf, int off, long[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = fSize / 8; // byte offset delta
    if (sign) {
      if (dSize == 8) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (long)unpackByte(buf, off);
        }
      }
      else {
        int shift  = 8 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (long)(unpackByte(buf, off) >> shift);
        }
      }
    }
    else {
      if (dSize == 8) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (long)(unpackByte(buf, off) & 0xFFL);
        }
      }
      else {
        int shift  = 8 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (long)((unpackByte(buf, off) & 0xFFL) >>> shift);
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast pack method for unsigned byte data.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void packBytes (byte[] buf, int off, long[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = fSize / 8; // byte offset delta
    byte valMask = (sign)? ((byte)-1) : ((byte)0xFFFFFFFFFFFFFFFFL); // Bit mask for input value (controls sign-extend)
    if (dSize == 8) {
      if (delta == 1) {
        for (int i = 0; i < length; i++,off+=1) {
          byte val = (byte)(((byte)array[offset++]) & valMask);
          packByte(buf, off, val);
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          byte val = (byte)(((byte)array[offset++]) & valMask);
          packByte(buf, off, val);
          off += 1;
          for (int j = 1; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
    else {
      int shift = 8 - dSize;
      if (delta == 1) {
        for (int i = 0; i < length; i++,off+=1) {
          byte val = (byte)(((byte)array[offset++]) & valMask);
          packByte(buf, off, (byte)(val << shift));
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          byte val = (byte)(((byte)array[offset++]) & valMask);
          packByte(buf, off, (byte)(val << shift));
          off += 1;
          for (int j = 1; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for signed Int4 (nibble) data.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
   *  @param fSize  (IN)  Item packing field size in bits (must be 4)
   *  @param dSize  (IN)  Data item size in bits (must be 4)
   *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackNibbles (byte[] buf, int off, long[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    if (sign) {
      for (int i = 0; i < length; i+=2) {
        int b = (int)buf[off++];
        array[offset++] = (long)((b << 24) >> 28); // shift & sign extend
        array[offset++] = (long)((b << 28) >> 28); // shift & sign extend
      }
    }
    else {
      for (int i = 0; i < length; i+=2) {
        int b = (int)buf[off++];
        array[offset++] = (long)((b >> 4) & 0xF);
        array[offset++] = (long)((b     ) & 0xF);
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast pack method for signed Int4 (nibble) data.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
   *  @param fSize  (IN)  Item packing field size in bits (must be 4)
   *  @param dSize  (IN)  Data item size in bits (must be 4)
   *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packNibbles (byte[] buf, int off, long[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    // Pack function for signed and are identical for nibble data, hence
    // 'sign' is unused here, but included in function definition for consistency.
    for (int i = 0; i < length; i+=2) {
      int first  = (int)array[offset++];
      int second = (int)array[offset++];
      buf[off++] = (byte)((first << 4) | (second & 0xF));
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for bit data. Each bit in the
   *  input buffer will be checked, a 0 bit will correspond to the value 0 and a
   *  1 bit will correspond to the value 1.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert (must be a multiple of 8)
   *  @param fSize  (IN)  Item packing field size in bits (must be 1)
   *  @param dSize  (IN)  Data item size in bits (must be 1)
   *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackBits (byte[] buf, int off, long[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    if (sign) {
      // This uses sign-extending principles to get each bit as 0 or -1 which reflects
      // the fact that 0/-1 and not 0/+1 are the available values in a one-bit use of
      // twos-complement.
      for (int i = 0; i < length; i+=8) {
        int b = (int)buf[off++];
        array[offset++] = (long)((b << 24) >> 31);
        array[offset++] = (long)((b << 25) >> 31);
        array[offset++] = (long)((b << 26) >> 31);
        array[offset++] = (long)((b << 27) >> 31);
        array[offset++] = (long)((b << 28) >> 31);
        array[offset++] = (long)((b << 29) >> 31);
        array[offset++] = (long)((b << 30) >> 31);
        array[offset++] = (long)((b << 31) >> 31);
      }
    }
    else {
      for (int i = 0; i < length; i+=8) {
        int b = (int)buf[off++];
        array[offset++] = (long)((b >> 7) & 0x1);
        array[offset++] = (long)((b >> 6) & 0x1);
        array[offset++] = (long)((b >> 5) & 0x1);
        array[offset++] = (long)((b >> 4) & 0x1);
        array[offset++] = (long)((b >> 3) & 0x1);
        array[offset++] = (long)((b >> 2) & 0x1);
        array[offset++] = (long)((b >> 1) & 0x1);
        array[offset++] = (long)((b     ) & 0x1);
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast pack method for bit data. Each value in the
   *  input array will be checked, a zero value will correspond to the bit 0 and
   *  any non-zero value will correspond to the bit 1.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert (must be a multiple of 8)
   *  @param fSize  (IN)  Item packing field size in bits (must be 1)
   *  @param dSize  (IN)  Data item size in bits (must be 1)
   *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packBits (byte[] buf, int off, long[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    // Pack function for signed and are identical for bit data, hence
    // 'sign' is unused here, but included in function definition for consistency.
    for (int i = 0; i < length; i+=8) {
      int b = 0;
      b |= (((long)array[offset++]) << 7) & 0x80;
      b |= (((long)array[offset++]) << 6) & 0x40;
      b |= (((long)array[offset++]) << 5) & 0x20;
      b |= (((long)array[offset++]) << 4) & 0x10;
      b |= (((long)array[offset++]) << 3) & 0x08;
      b |= (((long)array[offset++]) << 2) & 0x04;
      b |= (((long)array[offset++]) << 1) & 0x02;
      b |= (((long)array[offset++])     ) & 0x01;
      buf[off++] = (byte)b;
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array, where the data is
   *  aligned to 32-bit word boundaries.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array  (OUT) Output value array (not null)
   *  @param chan   (OUT) Output channel tag array (null if n/a)
   *  @param evt    (OUT) Output event tag array (null if n/a)
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits
   *  @param dSize  (IN)  Data item size in bits
   *  @param eSize  (IN)  Event tag size in bits
   *  @param cSize  (IN)  Channel tag size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackIntWord32 (byte[] buf, int off, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+- - - - - +
    //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
    //   +-----------+--------+-----------+-------------+- - - - - +
    //       dSize      uSize     eSize       cSize        pSize
    //   |------------------ fSize ---------------------|
    //   |---------------------- Word Size ------------------------|
    int    pSize    = 32 - fSize;
    int    evtMask  = ~(((int)-1) << eSize);
    int    chanMask = ~(((int)-1) << cSize);
    int valMask  = (sign)? ((int)-1) : (~(((int)-1) << dSize));
    for (int i = 0; i < length; i++,off+=4) {
      int value = unpackInt(buf, off);
      array[i] = (long)((value >> (32-dSize)) & valMask);
      if (chan != null) chan[i] = (value >> (pSize      )) & chanMask;
      if (evt  != null) evt[i]  = (value >> (pSize+cSize)) & evtMask;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array, where the data is
   *  aligned to 32-bit word boundaries.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input value array
   *  @param chan   (IN)  Input channel tag array (null if n/a)
   *  @param evt    (IN)  Input event tag array (null if n/a)
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits
   *  @param dSize  (IN)  Data item size in bits
   *  @param eSize  (IN)  Event tag size in bits
   *  @param cSize  (IN)  Channel tag size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packIntWord32 (byte[] buf, int off, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+- - - - - +
    //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
    //   +-----------+--------+-----------+-------------+- - - - - +
    //       dSize      uSize     eSize       cSize        pSize
    //   |------------------ fSize ---------------------|
    //   |---------------------- Word Size ------------------------|
    int    pSize    = 32 - fSize;
    int    evtMask  = ~(((int)-1) << eSize);
    int    chanMask = ~(((int)-1) << cSize);
    int valMask  = (sign)? ((int)-1) : ((int)0xFFFFFFFFFFFFFFFFL);
    for (int i = 0; i < length; i++,off+=4) {
      int val   = (int)(((int)array[i]) & valMask);
      int value = val << (32-dSize);
      if (chan != null) value |= (chan[i] & chanMask) << (pSize);
      if (evt  != null) value |= (evt[i]  & evtMask ) << (pSize+cSize);
      packInt(buf, off, value);
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array, where the data is
   *  aligned to 64-bit word boundaries.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array  (OUT) Output value array (not null)
   *  @param chan   (OUT) Output channel tag array (null if n/a)
   *  @param evt    (OUT) Output event tag array (null if n/a)
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits
   *  @param dSize  (IN)  Data item size in bits
   *  @param eSize  (IN)  Event tag size in bits
   *  @param cSize  (IN)  Channel tag size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackIntWord64 (byte[] buf, int off, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+- - - - - +
    //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
    //   +-----------+--------+-----------+-------------+- - - - - +
    //       dSize      uSize     eSize       cSize        pSize
    //   |------------------ fSize ---------------------|
    //   |---------------------- Word Size ------------------------|
    int    pSize    = 64 - fSize;
    int    evtMask  = ~(((int)-1) << eSize);
    int    chanMask = ~(((int)-1) << cSize);
    long valMask  = (sign)? ((long)-1) : (~(((long)-1) << dSize));
    if (dSize == 32) {
      // When using Int32/UInt32 the first 32-bits will always the the Int32/UInt32
      // value, so use 32-bit operations to improve performance
      for (int i = 0; i < length; i++,off+=8) {
        int val   = unpackInt(buf, off);
        int value = unpackInt(buf, off+4);
        array[i] = (long)(val & valMask);
        if (chan != null) chan[i] = ((int)(value >> (pSize      ))) & chanMask;
        if (evt  != null) evt[i]  = ((int)(value >> (pSize+cSize))) & evtMask;
      }
    }
    else {
      for (int i = 0; i < length; i++,off+=8) {
        long value = unpackLong(buf, off);
        array[i] = (long)((value >> (64-dSize)) & valMask);
        if (chan != null) chan[i] = ((int)(value >> (pSize      ))) & chanMask;
        if (evt  != null) evt[i]  = ((int)(value >> (pSize+cSize))) & evtMask;
      }
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array, where the data is
   *  aligned to 64-bit word boundaries.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input value array
   *  @param chan   (IN)  Input channel tag array (null if n/a)
   *  @param evt    (IN)  Input event tag array (null if n/a)
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits
   *  @param dSize  (IN)  Data item size in bits
   *  @param eSize  (IN)  Event tag size in bits
   *  @param cSize  (IN)  Channel tag size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packIntWord64 (byte[] buf, int off, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+- - - - - +
    //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
    //   +-----------+--------+-----------+-------------+- - - - - +
    //       dSize      uSize     eSize       cSize        pSize
    //   |------------------ fSize ---------------------|
    //   |---------------------- Word Size ------------------------|
    int    pSize    = 64 - fSize;
    int    evtMask  = ~(((int)-1) << eSize);
    int    chanMask = ~(((int)-1) << cSize);
    long valMask  = (sign)? ((long)-1) : ((long)0xFFFFFFFFFFFFFFFFL);
    if (dSize == 32) {
      // When using Int32/UInt32 the first 32-bits will always the the Int32/UInt32
      // value, so use 32-bit operations to improve performance
      for (int i = 0; i < length; i++,off+=8) {
        int val   = (int)(((long)array[i]) & valMask);
        int value = 0;
        if (chan != null) value  = (chan[i] & chanMask) << (pSize);
        if (evt  != null) value |= (evt[i]  & evtMask ) << (pSize+cSize);
        packInt(buf, off,   val);
        packInt(buf, off+4, value);
      }
    }
    else {
      for (int i = 0; i < length; i++,off+=8) {
        long val   = (long)(((long)array[i]) & valMask);
        long value = val << (64-dSize);
        if (chan != null) value |= ((long)(chan[i] & chanMask)) << (pSize);
        if (evt  != null) value |= ((long)(evt[i]  & evtMask )) << (pSize+cSize);
        packLong(buf, off, value);
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array, where the data is
   *  aligned to 64-bit word boundaries.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array  (OUT) Output value array (not null)
   *  @param chan   (OUT) Output channel tag array (null if n/a)
   *  @param evt    (OUT) Output event tag array (null if n/a)
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits
   *  @param dSize  (IN)  Data item size in bits
   *  @param eSize  (IN)  Event tag size in bits
   *  @param cSize  (IN)  Channel tag size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackFloatWord64 (byte[] buf, int off, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+- - - - - +
    //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
    //   +-----------+--------+-----------+-------------+- - - - - +
    //       dSize      uSize     eSize       cSize        pSize
    //   |------------------ fSize ---------------------|
    //   |---------------------- Word Size ------------------------|
    int    pSize    = 64 - fSize;
    int    evtMask  = ~(((int)-1) << eSize);
    int    chanMask = ~(((int)-1) << cSize);
    // When using Float32 the first 32-bits will always the the Float32 value, so
    // use 32-bit operations to improve performance
    for (int i = 0; i < length; i++,off+=8) {
      array[i] = (long)unpackFloat(buf, off);
      int value = unpackInt(buf, off+4);
      if (chan != null) chan[i] = (value >> (pSize      )) & chanMask;
      if (evt  != null) evt[i]  = (value >> (pSize+cSize)) & evtMask;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array, where the data is
   *  aligned to 64-bit word boundaries.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input value array
   *  @param chan   (IN)  Input channel tag array (null if n/a)
   *  @param evt    (IN)  Input event tag array (null if n/a)
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits
   *  @param dSize  (IN)  Data item size in bits
   *  @param eSize  (IN)  Event tag size in bits
   *  @param cSize  (IN)  Channel tag size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packFloatWord64 (byte[] buf, int off, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+- - - - - +
    //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
    //   +-----------+--------+-----------+-------------+- - - - - +
    //       dSize      uSize     eSize       cSize        pSize
    //   |------------------ fSize ---------------------|
    //   |---------------------- Word Size ------------------------|
    int    pSize    = 64 - fSize;
    int    evtMask  = ~(((int)-1) << eSize);
    int    chanMask = ~(((int)-1) << cSize);
    // When using Float32 the first 32-bits will always the the Float32 value, so
    // use 32-bit operations to improve performance
    for (int i = 0; i < length; i++,off+=8) {
      float val   = (float)array[i];
      int   value = 0;
      if (chan != null) value  = (chan[i] & chanMask) << (pSize);
      if (evt  != null) value |= (evt[i]  & evtMask ) << (pSize+cSize);
      packFloat(buf, off,   val);
      packInt(  buf, off+4, value);
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackIntBuffer32 (byte[] buf, int bitOffset, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_dSize  = 32 - dSize;    // pre-compute "32 - dSize" for efficiency
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        if (sign) {
          // sign extend
          array[offset] = (long)((value << _bits_dSize) >>  _bits_dSize);
        }
        else {
          // leave top bits (which default to 0) as 0
          array[offset] = (long)value;
        }
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packIntBuffer32 (byte[] buf, int bitOffset, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    int valMask      = (sign)? ((int)-1) : ((int)0xFFFFFFFFFFFFFFFFL); // Bit mask for input value (controls sign-extend)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        int arrayValue = ((int)array[offset]) & valMask;
        int value      = (int)((arrayValue) << (32 - dSize));
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackIntBuffer64 (byte[] buf, int bitOffset, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_dSize  = 64 - dSize;    // pre-compute "64 - dSize" for efficiency
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        if (sign) {
          // sign extend
          array[offset] = (long)((value << _bits_dSize) >>  _bits_dSize);
        }
        else {
          // leave top bits (which default to 0) as 0
          array[offset] = (long)value;
        }
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packIntBuffer64 (byte[] buf, int bitOffset, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    long valMask      = (sign)? ((long)-1) : ((long)0xFFFFFFFFFFFFFFFFL); // Bit mask for input value (controls sign-extend)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        long arrayValue = ((long)array[offset]) & valMask;
        long value      = (long)((arrayValue) << (64 - dSize));
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackFloatBuffer64 (byte[] buf, int bitOffset, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (long)intBitsToFloat((int)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packFloatBuffer64 (byte[] buf, int bitOffset, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        float  arrayValue = (float)array[offset];
        long   value      = ((long)floatToRawIntBits(arrayValue)) << 32;
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT1Buffer32 (byte[] buf, int bitOffset, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (long)fromVRTFloat(DataItemFormat.SignedVRT1, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT1Buffer32 (byte[] buf, int bitOffset, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.SignedVRT1, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT1Buffer64 (byte[] buf, int bitOffset, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (long)fromVRTFloat(DataItemFormat.SignedVRT1, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT1Buffer64 (byte[] buf, int bitOffset, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.SignedVRT1, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT2Buffer32 (byte[] buf, int bitOffset, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (long)fromVRTFloat(DataItemFormat.SignedVRT2, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT2Buffer32 (byte[] buf, int bitOffset, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.SignedVRT2, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT2Buffer64 (byte[] buf, int bitOffset, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (long)fromVRTFloat(DataItemFormat.SignedVRT2, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT2Buffer64 (byte[] buf, int bitOffset, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.SignedVRT2, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT3Buffer32 (byte[] buf, int bitOffset, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (long)fromVRTFloat(DataItemFormat.SignedVRT3, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT3Buffer32 (byte[] buf, int bitOffset, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.SignedVRT3, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT3Buffer64 (byte[] buf, int bitOffset, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (long)fromVRTFloat(DataItemFormat.SignedVRT3, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT3Buffer64 (byte[] buf, int bitOffset, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.SignedVRT3, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT4Buffer32 (byte[] buf, int bitOffset, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (long)fromVRTFloat(DataItemFormat.SignedVRT4, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT4Buffer32 (byte[] buf, int bitOffset, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.SignedVRT4, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT4Buffer64 (byte[] buf, int bitOffset, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (long)fromVRTFloat(DataItemFormat.SignedVRT4, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT4Buffer64 (byte[] buf, int bitOffset, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.SignedVRT4, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT5Buffer32 (byte[] buf, int bitOffset, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (long)fromVRTFloat(DataItemFormat.SignedVRT5, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT5Buffer32 (byte[] buf, int bitOffset, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.SignedVRT5, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT5Buffer64 (byte[] buf, int bitOffset, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (long)fromVRTFloat(DataItemFormat.SignedVRT5, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT5Buffer64 (byte[] buf, int bitOffset, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.SignedVRT5, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT6Buffer32 (byte[] buf, int bitOffset, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (long)fromVRTFloat(DataItemFormat.SignedVRT6, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT6Buffer32 (byte[] buf, int bitOffset, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.SignedVRT6, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT6Buffer64 (byte[] buf, int bitOffset, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (long)fromVRTFloat(DataItemFormat.SignedVRT6, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT6Buffer64 (byte[] buf, int bitOffset, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.SignedVRT6, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT1Buffer32 (byte[] buf, int bitOffset, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (long)fromVRTFloat(DataItemFormat.UnsignedVRT1, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT1Buffer32 (byte[] buf, int bitOffset, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.UnsignedVRT1, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT1Buffer64 (byte[] buf, int bitOffset, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (long)fromVRTFloat(DataItemFormat.UnsignedVRT1, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT1Buffer64 (byte[] buf, int bitOffset, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.UnsignedVRT1, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT2Buffer32 (byte[] buf, int bitOffset, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (long)fromVRTFloat(DataItemFormat.UnsignedVRT2, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT2Buffer32 (byte[] buf, int bitOffset, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.UnsignedVRT2, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT2Buffer64 (byte[] buf, int bitOffset, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (long)fromVRTFloat(DataItemFormat.UnsignedVRT2, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT2Buffer64 (byte[] buf, int bitOffset, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.UnsignedVRT2, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT3Buffer32 (byte[] buf, int bitOffset, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (long)fromVRTFloat(DataItemFormat.UnsignedVRT3, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT3Buffer32 (byte[] buf, int bitOffset, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.UnsignedVRT3, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT3Buffer64 (byte[] buf, int bitOffset, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (long)fromVRTFloat(DataItemFormat.UnsignedVRT3, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT3Buffer64 (byte[] buf, int bitOffset, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.UnsignedVRT3, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT4Buffer32 (byte[] buf, int bitOffset, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (long)fromVRTFloat(DataItemFormat.UnsignedVRT4, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT4Buffer32 (byte[] buf, int bitOffset, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.UnsignedVRT4, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT4Buffer64 (byte[] buf, int bitOffset, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (long)fromVRTFloat(DataItemFormat.UnsignedVRT4, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT4Buffer64 (byte[] buf, int bitOffset, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.UnsignedVRT4, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT5Buffer32 (byte[] buf, int bitOffset, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (long)fromVRTFloat(DataItemFormat.UnsignedVRT5, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT5Buffer32 (byte[] buf, int bitOffset, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.UnsignedVRT5, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT5Buffer64 (byte[] buf, int bitOffset, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (long)fromVRTFloat(DataItemFormat.UnsignedVRT5, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT5Buffer64 (byte[] buf, int bitOffset, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.UnsignedVRT5, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT6Buffer32 (byte[] buf, int bitOffset, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (long)fromVRTFloat(DataItemFormat.UnsignedVRT6, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT6Buffer32 (byte[] buf, int bitOffset, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.UnsignedVRT6, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT6Buffer64 (byte[] buf, int bitOffset, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (long)fromVRTFloat(DataItemFormat.UnsignedVRT6, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT6Buffer64 (byte[] buf, int bitOffset, long[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.UnsignedVRT6, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Unpacks values with the given format specifier as
   *  an array of <tt>long</tt>. <br>
   *  <br>
   *  Setting the channel tags (<tt>chan</tt>) and/or event tags (<tt>evt</tt>)
   *  arrays to null will cause any channel or event tags present to be ignored.
   *  In most cases this results in a performance improvement. <br>
   *  <br>
   *  If the channel tags (<tt>chan</tt>) and/or event tags (<tt>evt</tt>) arrays
   *  are non-null when there are no channel or event tags present, the values in
   *  the arrays will not be modified.
   *  @param pf     (IN)  The data format
   *  @param buf    (IN)  The buffer
   *  @param off    (IN)  The buffer offset
   *  @param array  (OUT) The output array for the values
   *  @param chan   (OUT) The output array for the channel tags (null if n/a)
   *  @param evt    (OUT) The output array for the event tags (null if n/a)
   *  @param length (IN)  Number of elements to convert
   *  @return The output array (same as <tt>array</tt>).
   */
  @SuppressWarnings("fallthrough")
  public static long[] unpackAsLong (PayloadFormat pf, byte[] buf, int off, long[] array, int[] chan, int[] evt, int length) {
    if (!pf.isValid()) {
      throw new IllegalArgumentException(pf.getValid());
    }
    int            fSize  = pf.getItemPackingFieldSize();
    int            dSize  = pf.getDataItemSize();
    int            eSize  = pf.getEventTagSize();
    int            cSize  = pf.getChannelTagSize();
    boolean        proc   = pf.isProcessingEfficient();
    boolean        sign   = pf.isSigned();
    DataItemFormat format = pf.getDataItemFormat();
    boolean        noTags;
    if (eSize == 0) evt  = null; // no event tags, ignore any array passed in
    if (cSize == 0) chan = null; // no channel tags, ignore any array passed in
    noTags = (chan == null) && (evt == null);
    if (proc && noTags && (fSize >= 17)) {
      // Use faster "effective field size" when ignoring Event & Channel Tags
      fSize = (fSize <= 32)? 32 : 64;
    }
    switch (format) {
      case SignedInt:   // FALLTHROUGH
      case UnsignedInt:
        // ---- Try fast methods -------------------------------------------------
        if (noTags) {
          switch (fSize) {
            case  8: unpackBytes(  buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
            case 16: unpackShorts( buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
            case 24: unpackInt24s( buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
            case 32: unpackInts(   buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
            case 64: unpackLongs(  buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
          }
        }
        if (fSize == dSize) { // implicit noTags=true in this case
          switch (fSize) {
            case  1: if ((length % 8) == 0) { unpackBits(   buf, off, array, 0, length, fSize, dSize, proc, sign); return array; } break;
            case  4: if ((length % 2) == 0) { unpackNibbles(buf, off, array, 0, length, fSize, dSize, proc, sign); return array; } break;
            case 12: if ((length % 2) == 0) { unpackInt12s( buf, off, array, 0, length, fSize, dSize, proc, sign); return array; } break;
          }
        }
        if ((proc && (fSize >= 17)) || (fSize == 32) || (fSize == 64)) {
          if (fSize <= 32) {
            unpackIntWord32(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
          }
          else {
            unpackIntWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
          }
        }
        // ---- Fall back to slow method -----------------------------------------
        if (fSize <= 32) {
          unpackIntBuffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackIntBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case Float:
        // ---- Try fast methods -------------------------------------------------
        if (fSize == dSize) { // implicit noTags=true in this case
          unpackFloats(buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
        }
        if ((proc && (fSize >= 33)) || (fSize == 64)) {
          unpackFloatWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        // ---- Fall back to slow method -----------------------------------------
        unpackFloatBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      case Double:
        // ---- Only fast method for double (yea!) -------------------------------
        unpackDoubles(buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
      case SignedVRT1:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackSignedVRT1Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackSignedVRT1Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case SignedVRT2:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackSignedVRT2Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackSignedVRT2Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case SignedVRT3:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackSignedVRT3Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackSignedVRT3Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case SignedVRT4:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackSignedVRT4Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackSignedVRT4Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case SignedVRT5:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackSignedVRT5Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackSignedVRT5Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case SignedVRT6:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackSignedVRT6Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackSignedVRT6Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case UnsignedVRT1:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackUnsignedVRT1Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackUnsignedVRT1Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case UnsignedVRT2:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackUnsignedVRT2Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackUnsignedVRT2Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case UnsignedVRT3:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackUnsignedVRT3Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackUnsignedVRT3Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case UnsignedVRT4:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackUnsignedVRT4Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackUnsignedVRT4Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case UnsignedVRT5:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackUnsignedVRT5Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackUnsignedVRT5Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case UnsignedVRT6:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackUnsignedVRT6Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackUnsignedVRT6Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      default:
        throw new UnsupportedOperationException("Unpacking of VRT float types not supported yet");
    }
  }
  /** <b>Internal Use Only:</b> Packs values with the given format specifier from
   *  an array of long. <br>
   *  <br>
   *  Setting the channel tags (<tt>chan</tt>) and/or event tags (<tt>evt</tt>)
   *  arrays to null will cause any channel or event tags present to be set to
   *  zero. In most cases this results in a performance improvement over passing
   *  in an array of zeros. <br>
   *  <br>
   *  If the channel tags (<tt>chan</tt>) and/or event tags (<tt>evt</tt>) arrays
   *  are non-null when there are no channel or event tags present, the values in
   *  the arrays will be ignored.
   *  @param pf     (IN)  The data format
   *  @param buf    (I/O) The buffer
   *  @param off    (IN)  The buffer offset
   *  @param array  (IN)  The values to pack
   *  @param chan   (OUT) The output array for the channel tags (null if n/a)
   *  @param evt    (OUT) The output array for the event tags (null if n/a)
   *  @param length (IN)  Number of elements to convert
   */
  @SuppressWarnings("fallthrough")
  public static void packAsLong (PayloadFormat pf, byte[] buf, int off, long[] array, int[] chan, int[] evt, int length) {
    if (!pf.isValid()) {
      throw new IllegalArgumentException(pf.getValid());
    }
    int            fSize  = pf.getItemPackingFieldSize();
    int            dSize  = pf.getDataItemSize();
    int            eSize  = pf.getEventTagSize();
    int            cSize  = pf.getChannelTagSize();
    boolean        proc   = pf.isProcessingEfficient();
    boolean        sign   = pf.isSigned();
    DataItemFormat format = pf.getDataItemFormat();
    boolean        noTags;
    if (eSize == 0) evt  = null; // no event tags, ignore any array passed in
    if (cSize == 0) chan = null; // no channel tags, ignore any array passed in
    noTags = (chan == null) && (evt == null);
    if (proc && noTags && (fSize >= 17)) {
      // Use faster "effective field size" when ignoring Event & Channel Tags
      fSize = (fSize <= 32)? 32 : 64;
    }
    switch (format) {
      case SignedInt:   // FALLTHROUGH
      case UnsignedInt:
        // ---- Try fast methods -------------------------------------------------
        if (noTags) {
          switch (fSize) {
            case  8: packBytes(  buf, off, array, 0, length, fSize, dSize, proc, sign); return;
            case 16: packShorts( buf, off, array, 0, length, fSize, dSize, proc, sign); return;
            case 24: packInt24s( buf, off, array, 0, length, fSize, dSize, proc, sign); return;
            case 32: packInts(   buf, off, array, 0, length, fSize, dSize, proc, sign); return;
            case 64: packLongs(  buf, off, array, 0, length, fSize, dSize, proc, sign); return;
          }
        }
        if (fSize == dSize) { // implicit noTags=true in this case
          switch (fSize) {
            case  1: if ((length % 8) == 0) { packBits(   buf, off, array, 0, length, fSize, dSize, proc, sign); return; } break;
            case  4: if ((length % 2) == 0) { packNibbles(buf, off, array, 0, length, fSize, dSize, proc, sign); return; } break;
            case 12: if ((length % 2) == 0) { packInt12s( buf, off, array, 0, length, fSize, dSize, proc, sign); return; } break;
          }
        }
        if ((proc && (fSize >= 17)) || (fSize == 32) || (fSize == 64)) {
          if (fSize <= 32) {
            packIntWord32(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
          }
          else {
            packIntWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
          }
        }
        // ---- Fall back to slow method -----------------------------------------
        if (fSize <= 32) {
          packIntBuffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packIntBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case Float:
        // ---- Try fast methods -------------------------------------------------
        if (fSize == dSize) { // implicit noTags=true in this case
          packFloats(buf, off, array, 0, length, fSize, dSize, proc, sign); return;
        }
        if ((proc && (fSize >= 33)) || (fSize == 64)) {
          packFloatWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        // ---- Fall back to slow method -----------------------------------------
        packFloatBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      case Double:
        // ---- Only fast method for double (yea!) -------------------------------
        packDoubles(buf, off, array, 0, length, fSize, dSize, proc, sign); return;
      case SignedVRT1:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packSignedVRT1Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packSignedVRT1Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case SignedVRT2:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packSignedVRT2Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packSignedVRT2Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case SignedVRT3:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packSignedVRT3Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packSignedVRT3Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case SignedVRT4:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packSignedVRT4Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packSignedVRT4Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case SignedVRT5:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packSignedVRT5Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packSignedVRT5Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case SignedVRT6:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packSignedVRT6Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packSignedVRT6Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case UnsignedVRT1:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packUnsignedVRT1Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packUnsignedVRT1Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case UnsignedVRT2:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packUnsignedVRT2Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packUnsignedVRT2Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case UnsignedVRT3:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packUnsignedVRT3Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packUnsignedVRT3Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case UnsignedVRT4:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packUnsignedVRT4Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packUnsignedVRT4Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case UnsignedVRT5:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packUnsignedVRT5Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packUnsignedVRT5Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case UnsignedVRT6:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packUnsignedVRT6Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packUnsignedVRT6Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      default:
        throw new UnsupportedOperationException("Packing of VRT float types not supported yet");
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for double data.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits (must be 64)
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed? (must be true)
   */
  @SuppressWarnings("cast")
  private static  void unpackDoubles (byte[] buf, int off, int[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    // All floating-point values are signed, so 'sign' is unused, but is included
    // in function definition for consistency.
    // When using Double data, it is required that dSize=64 and fSize=64 so we can
    // skip some of the normal checks we would otherwise do here.
    for (int i = 0; i < length; i++,off+=8) {
      array[offset++] = (int)unpackDouble(buf, off);
    }
  }
  /** <b>Internal Use Only:</b>
   *  Fast pack method for double data.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits (must be 64)
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed? (must be true)
   */
  @SuppressWarnings("cast")
  private static  void packDoubles (byte[] buf, int off, int[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    // All floating-point values are signed, so 'sign' is unused, but is included
    // in function definition for consistency.
    // When using Double data, it is required that dSize=64 and fSize=64 so we can
    // skip some of the normal checks we would otherwise do here.
    for (int i = 0; i < length; i++,off+=8) {
      packDouble(buf, off, (double)array[offset++]);
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for float data.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits (must be 32)
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed? (must be true)
   */
  @SuppressWarnings("cast")
  private static  void unpackFloats (byte[] buf, int off, int[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    // All floating-point values are signed, so 'sign' is unused, but is included
    // in function definition for consistency.
    int delta; // byte offset delta
    if (align) delta = (fSize <= 32)? 4 : 8;
    else       delta = fSize / 8;
    for (int i = 0; i < length; i++,off+=delta) {
      array[offset++] = (int)unpackFloat(buf, off);
    }
  }
  /** <b>Internal Use Only:</b>
   *  Fast pack method for float data.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits (must be 32)
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed? (must be true)
   */
  @SuppressWarnings("cast")
  private static  void packFloats (byte[] buf, int off, int[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    // All floating-point values are signed, so 'sign' is unused, but is included
    // in function definition for consistency.
    int delta; // byte offset delta
    if (align) delta = (fSize <= 32)? 4 : 8;
    else       delta = fSize / 8;
    if (delta == 4) {
      for (int i = 0; i < length; i++,off+=4) {
        packFloat(buf, off, (float)array[offset++]);
      }
    }
    else {
      for (int i = 0; i < length; i++) {
        packFloat(buf, off, (float)array[offset++]);
        off += 4;
        for (int j = 4; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for signed long data.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void unpackLongs (byte[] buf, int off, int[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // byte offset delta
    if (sign) {
      if (dSize == 64) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (int)unpackLong(buf, off);
        }
      }
      else {
        int shift  = 64 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (int)(unpackLong(buf, off) >> shift);
        }
      }
    }
    else {
      if (dSize == 64) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (int)(unpackLong(buf, off) & 0xFFFFFFFFFFFFFFFFL);
        }
      }
      else {
        int shift  = 64 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (int)((unpackLong(buf, off) & 0xFFFFFFFFFFFFFFFFL) >>> shift);
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast pack method for unsigned long data.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void packLongs (byte[] buf, int off, int[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // byte offset delta
    long valMask = (sign)? ((long)-1) : ((long)0xFFFFFFFFL); // Bit mask for input value (controls sign-extend)
    if (dSize == 64) {
      if (delta == 8) {
        for (int i = 0; i < length; i++,off+=8) {
          long val = (long)(((long)array[offset++]) & valMask);
          packLong(buf, off, val);
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          long val = (long)(((long)array[offset++]) & valMask);
          packLong(buf, off, val);
          off += 8;
          for (int j = 8; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
    else {
      int shift = 64 - dSize;
      if (delta == 8) {
        for (int i = 0; i < length; i++,off+=8) {
          long val = (long)(((long)array[offset++]) & valMask);
          packLong(buf, off, (long)(val << shift));
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          long val = (long)(((long)array[offset++]) & valMask);
          packLong(buf, off, (long)(val << shift));
          off += 8;
          for (int j = 8; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for signed int data.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void unpackInts (byte[] buf, int off, int[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // byte offset delta
    if (sign) {
      if (dSize == 32) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (int)unpackInt(buf, off);
        }
      }
      else {
        int shift  = 32 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (int)(unpackInt(buf, off) >> shift);
        }
      }
    }
    else {
      if (dSize == 32) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (int)(unpackInt(buf, off) & 0xFFFFFFFF);
        }
      }
      else {
        int shift  = 32 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (int)((unpackInt(buf, off) & 0xFFFFFFFF) >>> shift);
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast pack method for unsigned int data.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void packInts (byte[] buf, int off, int[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // byte offset delta
    int valMask = (sign)? ((int)-1) : ((int)0xFFFFFFFFL); // Bit mask for input value (controls sign-extend)
    if (dSize == 32) {
      if (delta == 4) {
        for (int i = 0; i < length; i++,off+=4) {
          int val = (int)(((int)array[offset++]) & valMask);
          packInt(buf, off, val);
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          int val = (int)(((int)array[offset++]) & valMask);
          packInt(buf, off, val);
          off += 4;
          for (int j = 4; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
    else {
      int shift = 32 - dSize;
      if (delta == 4) {
        for (int i = 0; i < length; i++,off+=4) {
          int val = (int)(((int)array[offset++]) & valMask);
          packInt(buf, off, (int)(val << shift));
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          int val = (int)(((int)array[offset++]) & valMask);
          packInt(buf, off, (int)(val << shift));
          off += 4;
          for (int j = 4; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for signed int data.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void unpackInt24s (byte[] buf, int off, int[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // byte offset delta
    if (sign) {
      if (dSize == 24) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (int)unpackInt24(buf, off);
        }
      }
      else {
        int shift  = 24 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (int)(unpackInt24(buf, off) >> shift);
        }
      }
    }
    else {
      if (dSize == 24) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (int)(unpackInt24(buf, off) & 0xFFFFFF);
        }
      }
      else {
        int shift  = 24 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (int)((unpackInt24(buf, off) & 0xFFFFFF) >>> shift);
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast pack method for unsigned int data.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void packInt24s (byte[] buf, int off, int[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // byte offset delta
    int valMask = (sign)? ((int)-1) : ((int)0xFFFFFFFFL); // Bit mask for input value (controls sign-extend)
    if (dSize == 24) {
      if (delta == 3) {
        for (int i = 0; i < length; i++,off+=3) {
          int val = (int)(((int)array[offset++]) & valMask);
          packInt24(buf, off, val);
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          int val = (int)(((int)array[offset++]) & valMask);
          packInt24(buf, off, val);
          off += 3;
          for (int j = 3; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
    else {
      int shift = 24 - dSize;
      if (delta == 3) {
        for (int i = 0; i < length; i++,off+=3) {
          int val = (int)(((int)array[offset++]) & valMask);
          packInt24(buf, off, (int)(val << shift));
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          int val = (int)(((int)array[offset++]) & valMask);
          packInt24(buf, off, (int)(val << shift));
          off += 3;
          for (int j = 3; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for signed short data.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void unpackShorts (byte[] buf, int off, int[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = fSize / 8; // byte offset delta
    if (sign) {
      if (dSize == 16) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (int)unpackShort(buf, off);
        }
      }
      else {
        int shift  = 16 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (int)(unpackShort(buf, off) >> shift);
        }
      }
    }
    else {
      if (dSize == 16) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (int)(unpackShort(buf, off) & 0xFFFF);
        }
      }
      else {
        int shift  = 16 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (int)((unpackShort(buf, off) & 0xFFFF) >>> shift);
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast pack method for unsigned short data.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void packShorts (byte[] buf, int off, int[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = fSize / 8; // byte offset delta
    short valMask = (sign)? ((short)-1) : ((short)0xFFFFFFFFL); // Bit mask for input value (controls sign-extend)
    if (dSize == 16) {
      if (delta == 2) {
        for (int i = 0; i < length; i++,off+=2) {
          short val = (short)(((short)array[offset++]) & valMask);
          packShort(buf, off, val);
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          short val = (short)(((short)array[offset++]) & valMask);
          packShort(buf, off, val);
          off += 2;
          for (int j = 2; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
    else {
      int shift = 16 - dSize;
      if (delta == 2) {
        for (int i = 0; i < length; i++,off+=2) {
          short val = (short)(((short)array[offset++]) & valMask);
          packShort(buf, off, (short)(val << shift));
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          short val = (short)(((short)array[offset++]) & valMask);
          packShort(buf, off, (short)(val << shift));
          off += 2;
          for (int j = 2; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for signed Int12 data.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
   *  @param fSize  (IN)  Item packing field size in bits (must be 12)
   *  @param dSize  (IN)  Data item size in bits (must be 12)
   *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackInt12s (byte[] buf, int off, int[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int skip = (align)? 1 : 0;
    if (sign) {
      for (int i = 0; i < length; i+=2) {
        int a = (int)buf[off++];
        int b = (int)buf[off++];
        int c = (int)buf[off++];
        int x = (a << 4) | ((b >> 4) & 0x000F);
        int y = (b << 8) | ((c     ) & 0x00FF);
        array[offset++] = (int)((x << 20) >> 20); // sign extend
        array[offset++] = (int)((y << 20) >> 20); // sign extend
        off += skip; // skip extra byte in processing-efficient mode
      }
    }
    else {
      for (int i = 0; i < length; i+=2) {
        int a = (int)buf[off++];
        int b = (int)buf[off++];
        int c = (int)buf[off++];
        int x = (a << 4) | ((b >> 4) & 0x000F);
        int y = (b << 8) | ((c     ) & 0x00FF);
        array[offset++] = (int)(x & 0x0FFF); // clear high-order bits
        array[offset++] = (int)(y & 0x0FFF); // clear high-order bits
        off += skip; // skip extra byte in processing-efficient mode
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast pack method for signed Int12 data.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
   *  @param fSize  (IN)  Item packing field size in bits (must be 12)
   *  @param dSize  (IN)  Data item size in bits (must be 12)
   *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packInt12s (byte[] buf, int off, int[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int skip = (align)?  1 : 0;
    int mask = (sign )? -1 : ((int)0xFFFFFFFFL);
    for (int i = 0; i < length; i+=2) {
      int first  = ((int)array[offset++]) & mask;
      int second = ((int)array[offset++]) & mask;
      buf[off++] = (byte)(first >> 4);
      buf[off++] = (byte)((first << 4) | ((second >> 8) & 0x0F));
      buf[off++] = (byte)(second);
      off += skip; // skip extra byte in processing-efficient mode
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for signed byte data.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void unpackBytes (byte[] buf, int off, int[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = fSize / 8; // byte offset delta
    if (sign) {
      if (dSize == 8) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (int)unpackByte(buf, off);
        }
      }
      else {
        int shift  = 8 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (int)(unpackByte(buf, off) >> shift);
        }
      }
    }
    else {
      if (dSize == 8) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (int)(unpackByte(buf, off) & 0xFF);
        }
      }
      else {
        int shift  = 8 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (int)((unpackByte(buf, off) & 0xFF) >>> shift);
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast pack method for unsigned byte data.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void packBytes (byte[] buf, int off, int[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = fSize / 8; // byte offset delta
    byte valMask = (sign)? ((byte)-1) : ((byte)0xFFFFFFFFL); // Bit mask for input value (controls sign-extend)
    if (dSize == 8) {
      if (delta == 1) {
        for (int i = 0; i < length; i++,off+=1) {
          byte val = (byte)(((byte)array[offset++]) & valMask);
          packByte(buf, off, val);
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          byte val = (byte)(((byte)array[offset++]) & valMask);
          packByte(buf, off, val);
          off += 1;
          for (int j = 1; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
    else {
      int shift = 8 - dSize;
      if (delta == 1) {
        for (int i = 0; i < length; i++,off+=1) {
          byte val = (byte)(((byte)array[offset++]) & valMask);
          packByte(buf, off, (byte)(val << shift));
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          byte val = (byte)(((byte)array[offset++]) & valMask);
          packByte(buf, off, (byte)(val << shift));
          off += 1;
          for (int j = 1; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for signed Int4 (nibble) data.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
   *  @param fSize  (IN)  Item packing field size in bits (must be 4)
   *  @param dSize  (IN)  Data item size in bits (must be 4)
   *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackNibbles (byte[] buf, int off, int[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    if (sign) {
      for (int i = 0; i < length; i+=2) {
        int b = (int)buf[off++];
        array[offset++] = (int)((b << 24) >> 28); // shift & sign extend
        array[offset++] = (int)((b << 28) >> 28); // shift & sign extend
      }
    }
    else {
      for (int i = 0; i < length; i+=2) {
        int b = (int)buf[off++];
        array[offset++] = (int)((b >> 4) & 0xF);
        array[offset++] = (int)((b     ) & 0xF);
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast pack method for signed Int4 (nibble) data.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
   *  @param fSize  (IN)  Item packing field size in bits (must be 4)
   *  @param dSize  (IN)  Data item size in bits (must be 4)
   *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packNibbles (byte[] buf, int off, int[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    // Pack function for signed and are identical for nibble data, hence
    // 'sign' is unused here, but included in function definition for consistency.
    for (int i = 0; i < length; i+=2) {
      int first  = (int)array[offset++];
      int second = (int)array[offset++];
      buf[off++] = (byte)((first << 4) | (second & 0xF));
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for bit data. Each bit in the
   *  input buffer will be checked, a 0 bit will correspond to the value 0 and a
   *  1 bit will correspond to the value 1.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert (must be a multiple of 8)
   *  @param fSize  (IN)  Item packing field size in bits (must be 1)
   *  @param dSize  (IN)  Data item size in bits (must be 1)
   *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackBits (byte[] buf, int off, int[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    if (sign) {
      // This uses sign-extending principles to get each bit as 0 or -1 which reflects
      // the fact that 0/-1 and not 0/+1 are the available values in a one-bit use of
      // twos-complement.
      for (int i = 0; i < length; i+=8) {
        int b = (int)buf[off++];
        array[offset++] = (int)((b << 24) >> 31);
        array[offset++] = (int)((b << 25) >> 31);
        array[offset++] = (int)((b << 26) >> 31);
        array[offset++] = (int)((b << 27) >> 31);
        array[offset++] = (int)((b << 28) >> 31);
        array[offset++] = (int)((b << 29) >> 31);
        array[offset++] = (int)((b << 30) >> 31);
        array[offset++] = (int)((b << 31) >> 31);
      }
    }
    else {
      for (int i = 0; i < length; i+=8) {
        int b = (int)buf[off++];
        array[offset++] = (int)((b >> 7) & 0x1);
        array[offset++] = (int)((b >> 6) & 0x1);
        array[offset++] = (int)((b >> 5) & 0x1);
        array[offset++] = (int)((b >> 4) & 0x1);
        array[offset++] = (int)((b >> 3) & 0x1);
        array[offset++] = (int)((b >> 2) & 0x1);
        array[offset++] = (int)((b >> 1) & 0x1);
        array[offset++] = (int)((b     ) & 0x1);
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast pack method for bit data. Each value in the
   *  input array will be checked, a zero value will correspond to the bit 0 and
   *  any non-zero value will correspond to the bit 1.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert (must be a multiple of 8)
   *  @param fSize  (IN)  Item packing field size in bits (must be 1)
   *  @param dSize  (IN)  Data item size in bits (must be 1)
   *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packBits (byte[] buf, int off, int[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    // Pack function for signed and are identical for bit data, hence
    // 'sign' is unused here, but included in function definition for consistency.
    for (int i = 0; i < length; i+=8) {
      int b = 0;
      b |= (((int)array[offset++]) << 7) & 0x80;
      b |= (((int)array[offset++]) << 6) & 0x40;
      b |= (((int)array[offset++]) << 5) & 0x20;
      b |= (((int)array[offset++]) << 4) & 0x10;
      b |= (((int)array[offset++]) << 3) & 0x08;
      b |= (((int)array[offset++]) << 2) & 0x04;
      b |= (((int)array[offset++]) << 1) & 0x02;
      b |= (((int)array[offset++])     ) & 0x01;
      buf[off++] = (byte)b;
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array, where the data is
   *  aligned to 32-bit word boundaries.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array  (OUT) Output value array (not null)
   *  @param chan   (OUT) Output channel tag array (null if n/a)
   *  @param evt    (OUT) Output event tag array (null if n/a)
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits
   *  @param dSize  (IN)  Data item size in bits
   *  @param eSize  (IN)  Event tag size in bits
   *  @param cSize  (IN)  Channel tag size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackIntWord32 (byte[] buf, int off, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+- - - - - +
    //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
    //   +-----------+--------+-----------+-------------+- - - - - +
    //       dSize      uSize     eSize       cSize        pSize
    //   |------------------ fSize ---------------------|
    //   |---------------------- Word Size ------------------------|
    int    pSize    = 32 - fSize;
    int    evtMask  = ~(((int)-1) << eSize);
    int    chanMask = ~(((int)-1) << cSize);
    int valMask  = (sign)? ((int)-1) : (~(((int)-1) << dSize));
    for (int i = 0; i < length; i++,off+=4) {
      int value = unpackInt(buf, off);
      array[i] = (int)((value >> (32-dSize)) & valMask);
      if (chan != null) chan[i] = (value >> (pSize      )) & chanMask;
      if (evt  != null) evt[i]  = (value >> (pSize+cSize)) & evtMask;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array, where the data is
   *  aligned to 32-bit word boundaries.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input value array
   *  @param chan   (IN)  Input channel tag array (null if n/a)
   *  @param evt    (IN)  Input event tag array (null if n/a)
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits
   *  @param dSize  (IN)  Data item size in bits
   *  @param eSize  (IN)  Event tag size in bits
   *  @param cSize  (IN)  Channel tag size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packIntWord32 (byte[] buf, int off, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+- - - - - +
    //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
    //   +-----------+--------+-----------+-------------+- - - - - +
    //       dSize      uSize     eSize       cSize        pSize
    //   |------------------ fSize ---------------------|
    //   |---------------------- Word Size ------------------------|
    int    pSize    = 32 - fSize;
    int    evtMask  = ~(((int)-1) << eSize);
    int    chanMask = ~(((int)-1) << cSize);
    int valMask  = (sign)? ((int)-1) : ((int)0xFFFFFFFFL);
    for (int i = 0; i < length; i++,off+=4) {
      int val   = (int)(((int)array[i]) & valMask);
      int value = val << (32-dSize);
      if (chan != null) value |= (chan[i] & chanMask) << (pSize);
      if (evt  != null) value |= (evt[i]  & evtMask ) << (pSize+cSize);
      packInt(buf, off, value);
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array, where the data is
   *  aligned to 64-bit word boundaries.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array  (OUT) Output value array (not null)
   *  @param chan   (OUT) Output channel tag array (null if n/a)
   *  @param evt    (OUT) Output event tag array (null if n/a)
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits
   *  @param dSize  (IN)  Data item size in bits
   *  @param eSize  (IN)  Event tag size in bits
   *  @param cSize  (IN)  Channel tag size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackIntWord64 (byte[] buf, int off, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+- - - - - +
    //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
    //   +-----------+--------+-----------+-------------+- - - - - +
    //       dSize      uSize     eSize       cSize        pSize
    //   |------------------ fSize ---------------------|
    //   |---------------------- Word Size ------------------------|
    int    pSize    = 64 - fSize;
    int    evtMask  = ~(((int)-1) << eSize);
    int    chanMask = ~(((int)-1) << cSize);
    long valMask  = (sign)? ((long)-1) : (~(((long)-1) << dSize));
    if (dSize == 32) {
      // When using Int32/UInt32 the first 32-bits will always the the Int32/UInt32
      // value, so use 32-bit operations to improve performance
      for (int i = 0; i < length; i++,off+=8) {
        int val   = unpackInt(buf, off);
        int value = unpackInt(buf, off+4);
        array[i] = (int)(val & valMask);
        if (chan != null) chan[i] = ((int)(value >> (pSize      ))) & chanMask;
        if (evt  != null) evt[i]  = ((int)(value >> (pSize+cSize))) & evtMask;
      }
    }
    else {
      for (int i = 0; i < length; i++,off+=8) {
        long value = unpackLong(buf, off);
        array[i] = (int)((value >> (64-dSize)) & valMask);
        if (chan != null) chan[i] = ((int)(value >> (pSize      ))) & chanMask;
        if (evt  != null) evt[i]  = ((int)(value >> (pSize+cSize))) & evtMask;
      }
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array, where the data is
   *  aligned to 64-bit word boundaries.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input value array
   *  @param chan   (IN)  Input channel tag array (null if n/a)
   *  @param evt    (IN)  Input event tag array (null if n/a)
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits
   *  @param dSize  (IN)  Data item size in bits
   *  @param eSize  (IN)  Event tag size in bits
   *  @param cSize  (IN)  Channel tag size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packIntWord64 (byte[] buf, int off, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+- - - - - +
    //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
    //   +-----------+--------+-----------+-------------+- - - - - +
    //       dSize      uSize     eSize       cSize        pSize
    //   |------------------ fSize ---------------------|
    //   |---------------------- Word Size ------------------------|
    int    pSize    = 64 - fSize;
    int    evtMask  = ~(((int)-1) << eSize);
    int    chanMask = ~(((int)-1) << cSize);
    long valMask  = (sign)? ((long)-1) : ((long)0xFFFFFFFFL);
    if (dSize == 32) {
      // When using Int32/UInt32 the first 32-bits will always the the Int32/UInt32
      // value, so use 32-bit operations to improve performance
      for (int i = 0; i < length; i++,off+=8) {
        int val   = (int)(((long)array[i]) & valMask);
        int value = 0;
        if (chan != null) value  = (chan[i] & chanMask) << (pSize);
        if (evt  != null) value |= (evt[i]  & evtMask ) << (pSize+cSize);
        packInt(buf, off,   val);
        packInt(buf, off+4, value);
      }
    }
    else {
      for (int i = 0; i < length; i++,off+=8) {
        long val   = (long)(((long)array[i]) & valMask);
        long value = val << (64-dSize);
        if (chan != null) value |= ((long)(chan[i] & chanMask)) << (pSize);
        if (evt  != null) value |= ((long)(evt[i]  & evtMask )) << (pSize+cSize);
        packLong(buf, off, value);
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array, where the data is
   *  aligned to 64-bit word boundaries.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array  (OUT) Output value array (not null)
   *  @param chan   (OUT) Output channel tag array (null if n/a)
   *  @param evt    (OUT) Output event tag array (null if n/a)
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits
   *  @param dSize  (IN)  Data item size in bits
   *  @param eSize  (IN)  Event tag size in bits
   *  @param cSize  (IN)  Channel tag size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackFloatWord64 (byte[] buf, int off, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+- - - - - +
    //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
    //   +-----------+--------+-----------+-------------+- - - - - +
    //       dSize      uSize     eSize       cSize        pSize
    //   |------------------ fSize ---------------------|
    //   |---------------------- Word Size ------------------------|
    int    pSize    = 64 - fSize;
    int    evtMask  = ~(((int)-1) << eSize);
    int    chanMask = ~(((int)-1) << cSize);
    // When using Float32 the first 32-bits will always the the Float32 value, so
    // use 32-bit operations to improve performance
    for (int i = 0; i < length; i++,off+=8) {
      array[i] = (int)unpackFloat(buf, off);
      int value = unpackInt(buf, off+4);
      if (chan != null) chan[i] = (value >> (pSize      )) & chanMask;
      if (evt  != null) evt[i]  = (value >> (pSize+cSize)) & evtMask;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array, where the data is
   *  aligned to 64-bit word boundaries.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input value array
   *  @param chan   (IN)  Input channel tag array (null if n/a)
   *  @param evt    (IN)  Input event tag array (null if n/a)
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits
   *  @param dSize  (IN)  Data item size in bits
   *  @param eSize  (IN)  Event tag size in bits
   *  @param cSize  (IN)  Channel tag size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packFloatWord64 (byte[] buf, int off, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+- - - - - +
    //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
    //   +-----------+--------+-----------+-------------+- - - - - +
    //       dSize      uSize     eSize       cSize        pSize
    //   |------------------ fSize ---------------------|
    //   |---------------------- Word Size ------------------------|
    int    pSize    = 64 - fSize;
    int    evtMask  = ~(((int)-1) << eSize);
    int    chanMask = ~(((int)-1) << cSize);
    // When using Float32 the first 32-bits will always the the Float32 value, so
    // use 32-bit operations to improve performance
    for (int i = 0; i < length; i++,off+=8) {
      float val   = (float)array[i];
      int   value = 0;
      if (chan != null) value  = (chan[i] & chanMask) << (pSize);
      if (evt  != null) value |= (evt[i]  & evtMask ) << (pSize+cSize);
      packFloat(buf, off,   val);
      packInt(  buf, off+4, value);
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackIntBuffer32 (byte[] buf, int bitOffset, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_dSize  = 32 - dSize;    // pre-compute "32 - dSize" for efficiency
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        if (sign) {
          // sign extend
          array[offset] = (int)((value << _bits_dSize) >>  _bits_dSize);
        }
        else {
          // leave top bits (which default to 0) as 0
          array[offset] = (int)value;
        }
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packIntBuffer32 (byte[] buf, int bitOffset, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    int valMask      = (sign)? ((int)-1) : ((int)0xFFFFFFFFL); // Bit mask for input value (controls sign-extend)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        int arrayValue = ((int)array[offset]) & valMask;
        int value      = (int)((arrayValue) << (32 - dSize));
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackIntBuffer64 (byte[] buf, int bitOffset, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_dSize  = 64 - dSize;    // pre-compute "64 - dSize" for efficiency
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        if (sign) {
          // sign extend
          array[offset] = (int)((value << _bits_dSize) >>  _bits_dSize);
        }
        else {
          // leave top bits (which default to 0) as 0
          array[offset] = (int)value;
        }
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packIntBuffer64 (byte[] buf, int bitOffset, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    long valMask      = (sign)? ((long)-1) : ((long)0xFFFFFFFFL); // Bit mask for input value (controls sign-extend)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        long arrayValue = ((long)array[offset]) & valMask;
        long value      = (long)((arrayValue) << (64 - dSize));
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackFloatBuffer64 (byte[] buf, int bitOffset, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (int)intBitsToFloat((int)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packFloatBuffer64 (byte[] buf, int bitOffset, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        float  arrayValue = (float)array[offset];
        long   value      = ((long)floatToRawIntBits(arrayValue)) << 32;
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT1Buffer32 (byte[] buf, int bitOffset, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (int)fromVRTFloat(DataItemFormat.SignedVRT1, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT1Buffer32 (byte[] buf, int bitOffset, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.SignedVRT1, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT1Buffer64 (byte[] buf, int bitOffset, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (int)fromVRTFloat(DataItemFormat.SignedVRT1, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT1Buffer64 (byte[] buf, int bitOffset, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.SignedVRT1, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT2Buffer32 (byte[] buf, int bitOffset, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (int)fromVRTFloat(DataItemFormat.SignedVRT2, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT2Buffer32 (byte[] buf, int bitOffset, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.SignedVRT2, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT2Buffer64 (byte[] buf, int bitOffset, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (int)fromVRTFloat(DataItemFormat.SignedVRT2, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT2Buffer64 (byte[] buf, int bitOffset, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.SignedVRT2, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT3Buffer32 (byte[] buf, int bitOffset, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (int)fromVRTFloat(DataItemFormat.SignedVRT3, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT3Buffer32 (byte[] buf, int bitOffset, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.SignedVRT3, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT3Buffer64 (byte[] buf, int bitOffset, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (int)fromVRTFloat(DataItemFormat.SignedVRT3, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT3Buffer64 (byte[] buf, int bitOffset, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.SignedVRT3, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT4Buffer32 (byte[] buf, int bitOffset, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (int)fromVRTFloat(DataItemFormat.SignedVRT4, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT4Buffer32 (byte[] buf, int bitOffset, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.SignedVRT4, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT4Buffer64 (byte[] buf, int bitOffset, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (int)fromVRTFloat(DataItemFormat.SignedVRT4, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT4Buffer64 (byte[] buf, int bitOffset, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.SignedVRT4, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT5Buffer32 (byte[] buf, int bitOffset, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (int)fromVRTFloat(DataItemFormat.SignedVRT5, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT5Buffer32 (byte[] buf, int bitOffset, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.SignedVRT5, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT5Buffer64 (byte[] buf, int bitOffset, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (int)fromVRTFloat(DataItemFormat.SignedVRT5, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT5Buffer64 (byte[] buf, int bitOffset, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.SignedVRT5, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT6Buffer32 (byte[] buf, int bitOffset, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (int)fromVRTFloat(DataItemFormat.SignedVRT6, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT6Buffer32 (byte[] buf, int bitOffset, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.SignedVRT6, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT6Buffer64 (byte[] buf, int bitOffset, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (int)fromVRTFloat(DataItemFormat.SignedVRT6, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT6Buffer64 (byte[] buf, int bitOffset, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.SignedVRT6, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT1Buffer32 (byte[] buf, int bitOffset, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (int)fromVRTFloat(DataItemFormat.UnsignedVRT1, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT1Buffer32 (byte[] buf, int bitOffset, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.UnsignedVRT1, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT1Buffer64 (byte[] buf, int bitOffset, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (int)fromVRTFloat(DataItemFormat.UnsignedVRT1, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT1Buffer64 (byte[] buf, int bitOffset, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.UnsignedVRT1, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT2Buffer32 (byte[] buf, int bitOffset, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (int)fromVRTFloat(DataItemFormat.UnsignedVRT2, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT2Buffer32 (byte[] buf, int bitOffset, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.UnsignedVRT2, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT2Buffer64 (byte[] buf, int bitOffset, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (int)fromVRTFloat(DataItemFormat.UnsignedVRT2, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT2Buffer64 (byte[] buf, int bitOffset, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.UnsignedVRT2, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT3Buffer32 (byte[] buf, int bitOffset, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (int)fromVRTFloat(DataItemFormat.UnsignedVRT3, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT3Buffer32 (byte[] buf, int bitOffset, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.UnsignedVRT3, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT3Buffer64 (byte[] buf, int bitOffset, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (int)fromVRTFloat(DataItemFormat.UnsignedVRT3, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT3Buffer64 (byte[] buf, int bitOffset, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.UnsignedVRT3, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT4Buffer32 (byte[] buf, int bitOffset, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (int)fromVRTFloat(DataItemFormat.UnsignedVRT4, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT4Buffer32 (byte[] buf, int bitOffset, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.UnsignedVRT4, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT4Buffer64 (byte[] buf, int bitOffset, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (int)fromVRTFloat(DataItemFormat.UnsignedVRT4, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT4Buffer64 (byte[] buf, int bitOffset, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.UnsignedVRT4, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT5Buffer32 (byte[] buf, int bitOffset, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (int)fromVRTFloat(DataItemFormat.UnsignedVRT5, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT5Buffer32 (byte[] buf, int bitOffset, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.UnsignedVRT5, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT5Buffer64 (byte[] buf, int bitOffset, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (int)fromVRTFloat(DataItemFormat.UnsignedVRT5, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT5Buffer64 (byte[] buf, int bitOffset, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.UnsignedVRT5, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT6Buffer32 (byte[] buf, int bitOffset, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (int)fromVRTFloat(DataItemFormat.UnsignedVRT6, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT6Buffer32 (byte[] buf, int bitOffset, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.UnsignedVRT6, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT6Buffer64 (byte[] buf, int bitOffset, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (int)fromVRTFloat(DataItemFormat.UnsignedVRT6, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT6Buffer64 (byte[] buf, int bitOffset, int[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.UnsignedVRT6, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Unpacks values with the given format specifier as
   *  an array of <tt>int</tt>. <br>
   *  <br>
   *  Setting the channel tags (<tt>chan</tt>) and/or event tags (<tt>evt</tt>)
   *  arrays to null will cause any channel or event tags present to be ignored.
   *  In most cases this results in a performance improvement. <br>
   *  <br>
   *  If the channel tags (<tt>chan</tt>) and/or event tags (<tt>evt</tt>) arrays
   *  are non-null when there are no channel or event tags present, the values in
   *  the arrays will not be modified.
   *  @param pf     (IN)  The data format
   *  @param buf    (IN)  The buffer
   *  @param off    (IN)  The buffer offset
   *  @param array  (OUT) The output array for the values
   *  @param chan   (OUT) The output array for the channel tags (null if n/a)
   *  @param evt    (OUT) The output array for the event tags (null if n/a)
   *  @param length (IN)  Number of elements to convert
   *  @return The output array (same as <tt>array</tt>).
   */
  @SuppressWarnings("fallthrough")
  public static int[] unpackAsInt (PayloadFormat pf, byte[] buf, int off, int[] array, int[] chan, int[] evt, int length) {
    if (!pf.isValid()) {
      throw new IllegalArgumentException(pf.getValid());
    }
    int            fSize  = pf.getItemPackingFieldSize();
    int            dSize  = pf.getDataItemSize();
    int            eSize  = pf.getEventTagSize();
    int            cSize  = pf.getChannelTagSize();
    boolean        proc   = pf.isProcessingEfficient();
    boolean        sign   = pf.isSigned();
    DataItemFormat format = pf.getDataItemFormat();
    boolean        noTags;
    if (eSize == 0) evt  = null; // no event tags, ignore any array passed in
    if (cSize == 0) chan = null; // no channel tags, ignore any array passed in
    noTags = (chan == null) && (evt == null);
    if (proc && noTags && (fSize >= 17)) {
      // Use faster "effective field size" when ignoring Event & Channel Tags
      fSize = (fSize <= 32)? 32 : 64;
    }
    switch (format) {
      case SignedInt:   // FALLTHROUGH
      case UnsignedInt:
        // ---- Try fast methods -------------------------------------------------
        if (noTags) {
          switch (fSize) {
            case  8: unpackBytes(  buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
            case 16: unpackShorts( buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
            case 24: unpackInt24s( buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
            case 32: unpackInts(   buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
            case 64: unpackLongs(  buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
          }
        }
        if (fSize == dSize) { // implicit noTags=true in this case
          switch (fSize) {
            case  1: if ((length % 8) == 0) { unpackBits(   buf, off, array, 0, length, fSize, dSize, proc, sign); return array; } break;
            case  4: if ((length % 2) == 0) { unpackNibbles(buf, off, array, 0, length, fSize, dSize, proc, sign); return array; } break;
            case 12: if ((length % 2) == 0) { unpackInt12s( buf, off, array, 0, length, fSize, dSize, proc, sign); return array; } break;
          }
        }
        if ((proc && (fSize >= 17)) || (fSize == 32) || (fSize == 64)) {
          if (fSize <= 32) {
            unpackIntWord32(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
          }
          else {
            unpackIntWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
          }
        }
        // ---- Fall back to slow method -----------------------------------------
        if (fSize <= 32) {
          unpackIntBuffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackIntBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case Float:
        // ---- Try fast methods -------------------------------------------------
        if (fSize == dSize) { // implicit noTags=true in this case
          unpackFloats(buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
        }
        if ((proc && (fSize >= 33)) || (fSize == 64)) {
          unpackFloatWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        // ---- Fall back to slow method -----------------------------------------
        unpackFloatBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      case Double:
        // ---- Only fast method for double (yea!) -------------------------------
        unpackDoubles(buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
      case SignedVRT1:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackSignedVRT1Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackSignedVRT1Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case SignedVRT2:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackSignedVRT2Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackSignedVRT2Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case SignedVRT3:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackSignedVRT3Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackSignedVRT3Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case SignedVRT4:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackSignedVRT4Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackSignedVRT4Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case SignedVRT5:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackSignedVRT5Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackSignedVRT5Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case SignedVRT6:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackSignedVRT6Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackSignedVRT6Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case UnsignedVRT1:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackUnsignedVRT1Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackUnsignedVRT1Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case UnsignedVRT2:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackUnsignedVRT2Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackUnsignedVRT2Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case UnsignedVRT3:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackUnsignedVRT3Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackUnsignedVRT3Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case UnsignedVRT4:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackUnsignedVRT4Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackUnsignedVRT4Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case UnsignedVRT5:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackUnsignedVRT5Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackUnsignedVRT5Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case UnsignedVRT6:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackUnsignedVRT6Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackUnsignedVRT6Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      default:
        throw new UnsupportedOperationException("Unpacking of VRT float types not supported yet");
    }
  }
  /** <b>Internal Use Only:</b> Packs values with the given format specifier from
   *  an array of int. <br>
   *  <br>
   *  Setting the channel tags (<tt>chan</tt>) and/or event tags (<tt>evt</tt>)
   *  arrays to null will cause any channel or event tags present to be set to
   *  zero. In most cases this results in a performance improvement over passing
   *  in an array of zeros. <br>
   *  <br>
   *  If the channel tags (<tt>chan</tt>) and/or event tags (<tt>evt</tt>) arrays
   *  are non-null when there are no channel or event tags present, the values in
   *  the arrays will be ignored.
   *  @param pf     (IN)  The data format
   *  @param buf    (I/O) The buffer
   *  @param off    (IN)  The buffer offset
   *  @param array  (IN)  The values to pack
   *  @param chan   (OUT) The output array for the channel tags (null if n/a)
   *  @param evt    (OUT) The output array for the event tags (null if n/a)
   *  @param length (IN)  Number of elements to convert
   */
  @SuppressWarnings("fallthrough")
  public static void packAsInt (PayloadFormat pf, byte[] buf, int off, int[] array, int[] chan, int[] evt, int length) {
    if (!pf.isValid()) {
      throw new IllegalArgumentException(pf.getValid());
    }
    int            fSize  = pf.getItemPackingFieldSize();
    int            dSize  = pf.getDataItemSize();
    int            eSize  = pf.getEventTagSize();
    int            cSize  = pf.getChannelTagSize();
    boolean        proc   = pf.isProcessingEfficient();
    boolean        sign   = pf.isSigned();
    DataItemFormat format = pf.getDataItemFormat();
    boolean        noTags;
    if (eSize == 0) evt  = null; // no event tags, ignore any array passed in
    if (cSize == 0) chan = null; // no channel tags, ignore any array passed in
    noTags = (chan == null) && (evt == null);
    if (proc && noTags && (fSize >= 17)) {
      // Use faster "effective field size" when ignoring Event & Channel Tags
      fSize = (fSize <= 32)? 32 : 64;
    }
    switch (format) {
      case SignedInt:   // FALLTHROUGH
      case UnsignedInt:
        // ---- Try fast methods -------------------------------------------------
        if (noTags) {
          switch (fSize) {
            case  8: packBytes(  buf, off, array, 0, length, fSize, dSize, proc, sign); return;
            case 16: packShorts( buf, off, array, 0, length, fSize, dSize, proc, sign); return;
            case 24: packInt24s( buf, off, array, 0, length, fSize, dSize, proc, sign); return;
            case 32: packInts(   buf, off, array, 0, length, fSize, dSize, proc, sign); return;
            case 64: packLongs(  buf, off, array, 0, length, fSize, dSize, proc, sign); return;
          }
        }
        if (fSize == dSize) { // implicit noTags=true in this case
          switch (fSize) {
            case  1: if ((length % 8) == 0) { packBits(   buf, off, array, 0, length, fSize, dSize, proc, sign); return; } break;
            case  4: if ((length % 2) == 0) { packNibbles(buf, off, array, 0, length, fSize, dSize, proc, sign); return; } break;
            case 12: if ((length % 2) == 0) { packInt12s( buf, off, array, 0, length, fSize, dSize, proc, sign); return; } break;
          }
        }
        if ((proc && (fSize >= 17)) || (fSize == 32) || (fSize == 64)) {
          if (fSize <= 32) {
            packIntWord32(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
          }
          else {
            packIntWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
          }
        }
        // ---- Fall back to slow method -----------------------------------------
        if (fSize <= 32) {
          packIntBuffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packIntBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case Float:
        // ---- Try fast methods -------------------------------------------------
        if (fSize == dSize) { // implicit noTags=true in this case
          packFloats(buf, off, array, 0, length, fSize, dSize, proc, sign); return;
        }
        if ((proc && (fSize >= 33)) || (fSize == 64)) {
          packFloatWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        // ---- Fall back to slow method -----------------------------------------
        packFloatBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      case Double:
        // ---- Only fast method for double (yea!) -------------------------------
        packDoubles(buf, off, array, 0, length, fSize, dSize, proc, sign); return;
      case SignedVRT1:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packSignedVRT1Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packSignedVRT1Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case SignedVRT2:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packSignedVRT2Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packSignedVRT2Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case SignedVRT3:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packSignedVRT3Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packSignedVRT3Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case SignedVRT4:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packSignedVRT4Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packSignedVRT4Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case SignedVRT5:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packSignedVRT5Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packSignedVRT5Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case SignedVRT6:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packSignedVRT6Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packSignedVRT6Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case UnsignedVRT1:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packUnsignedVRT1Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packUnsignedVRT1Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case UnsignedVRT2:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packUnsignedVRT2Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packUnsignedVRT2Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case UnsignedVRT3:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packUnsignedVRT3Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packUnsignedVRT3Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case UnsignedVRT4:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packUnsignedVRT4Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packUnsignedVRT4Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case UnsignedVRT5:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packUnsignedVRT5Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packUnsignedVRT5Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case UnsignedVRT6:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packUnsignedVRT6Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packUnsignedVRT6Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      default:
        throw new UnsupportedOperationException("Packing of VRT float types not supported yet");
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for double data.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits (must be 64)
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed? (must be true)
   */
  @SuppressWarnings("cast")
  private static  void unpackDoubles (byte[] buf, int off, short[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    // All floating-point values are signed, so 'sign' is unused, but is included
    // in function definition for consistency.
    // When using Double data, it is required that dSize=64 and fSize=64 so we can
    // skip some of the normal checks we would otherwise do here.
    for (int i = 0; i < length; i++,off+=8) {
      array[offset++] = (short)unpackDouble(buf, off);
    }
  }
  /** <b>Internal Use Only:</b>
   *  Fast pack method for double data.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits (must be 64)
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed? (must be true)
   */
  @SuppressWarnings("cast")
  private static  void packDoubles (byte[] buf, int off, short[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    // All floating-point values are signed, so 'sign' is unused, but is included
    // in function definition for consistency.
    // When using Double data, it is required that dSize=64 and fSize=64 so we can
    // skip some of the normal checks we would otherwise do here.
    for (int i = 0; i < length; i++,off+=8) {
      packDouble(buf, off, (double)array[offset++]);
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for float data.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits (must be 32)
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed? (must be true)
   */
  @SuppressWarnings("cast")
  private static  void unpackFloats (byte[] buf, int off, short[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    // All floating-point values are signed, so 'sign' is unused, but is included
    // in function definition for consistency.
    int delta; // byte offset delta
    if (align) delta = (fSize <= 32)? 4 : 8;
    else       delta = fSize / 8;
    for (int i = 0; i < length; i++,off+=delta) {
      array[offset++] = (short)unpackFloat(buf, off);
    }
  }
  /** <b>Internal Use Only:</b>
   *  Fast pack method for float data.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits (must be 32)
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed? (must be true)
   */
  @SuppressWarnings("cast")
  private static  void packFloats (byte[] buf, int off, short[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    // All floating-point values are signed, so 'sign' is unused, but is included
    // in function definition for consistency.
    int delta; // byte offset delta
    if (align) delta = (fSize <= 32)? 4 : 8;
    else       delta = fSize / 8;
    if (delta == 4) {
      for (int i = 0; i < length; i++,off+=4) {
        packFloat(buf, off, (float)array[offset++]);
      }
    }
    else {
      for (int i = 0; i < length; i++) {
        packFloat(buf, off, (float)array[offset++]);
        off += 4;
        for (int j = 4; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for signed long data.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void unpackLongs (byte[] buf, int off, short[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // byte offset delta
    if (sign) {
      if (dSize == 64) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (short)unpackLong(buf, off);
        }
      }
      else {
        int shift  = 64 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (short)(unpackLong(buf, off) >> shift);
        }
      }
    }
    else {
      if (dSize == 64) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (short)(unpackLong(buf, off) & 0xFFFFFFFFFFFFFFFFL);
        }
      }
      else {
        int shift  = 64 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (short)((unpackLong(buf, off) & 0xFFFFFFFFFFFFFFFFL) >>> shift);
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast pack method for unsigned long data.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void packLongs (byte[] buf, int off, short[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // byte offset delta
    long valMask = (sign)? ((long)-1) : ((long)0xFFFFL); // Bit mask for input value (controls sign-extend)
    if (dSize == 64) {
      if (delta == 8) {
        for (int i = 0; i < length; i++,off+=8) {
          long val = (long)(((long)array[offset++]) & valMask);
          packLong(buf, off, val);
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          long val = (long)(((long)array[offset++]) & valMask);
          packLong(buf, off, val);
          off += 8;
          for (int j = 8; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
    else {
      int shift = 64 - dSize;
      if (delta == 8) {
        for (int i = 0; i < length; i++,off+=8) {
          long val = (long)(((long)array[offset++]) & valMask);
          packLong(buf, off, (long)(val << shift));
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          long val = (long)(((long)array[offset++]) & valMask);
          packLong(buf, off, (long)(val << shift));
          off += 8;
          for (int j = 8; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for signed int data.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void unpackInts (byte[] buf, int off, short[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // byte offset delta
    if (sign) {
      if (dSize == 32) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (short)unpackInt(buf, off);
        }
      }
      else {
        int shift  = 32 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (short)(unpackInt(buf, off) >> shift);
        }
      }
    }
    else {
      if (dSize == 32) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (short)(unpackInt(buf, off) & 0xFFFFFFFF);
        }
      }
      else {
        int shift  = 32 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (short)((unpackInt(buf, off) & 0xFFFFFFFF) >>> shift);
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast pack method for unsigned int data.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void packInts (byte[] buf, int off, short[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // byte offset delta
    int valMask = (sign)? ((int)-1) : ((int)0xFFFFL); // Bit mask for input value (controls sign-extend)
    if (dSize == 32) {
      if (delta == 4) {
        for (int i = 0; i < length; i++,off+=4) {
          int val = (int)(((int)array[offset++]) & valMask);
          packInt(buf, off, val);
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          int val = (int)(((int)array[offset++]) & valMask);
          packInt(buf, off, val);
          off += 4;
          for (int j = 4; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
    else {
      int shift = 32 - dSize;
      if (delta == 4) {
        for (int i = 0; i < length; i++,off+=4) {
          int val = (int)(((int)array[offset++]) & valMask);
          packInt(buf, off, (int)(val << shift));
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          int val = (int)(((int)array[offset++]) & valMask);
          packInt(buf, off, (int)(val << shift));
          off += 4;
          for (int j = 4; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for signed int data.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void unpackInt24s (byte[] buf, int off, short[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // byte offset delta
    if (sign) {
      if (dSize == 24) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (short)unpackInt24(buf, off);
        }
      }
      else {
        int shift  = 24 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (short)(unpackInt24(buf, off) >> shift);
        }
      }
    }
    else {
      if (dSize == 24) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (short)(unpackInt24(buf, off) & 0xFFFFFF);
        }
      }
      else {
        int shift  = 24 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (short)((unpackInt24(buf, off) & 0xFFFFFF) >>> shift);
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast pack method for unsigned int data.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void packInt24s (byte[] buf, int off, short[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // byte offset delta
    int valMask = (sign)? ((int)-1) : ((int)0xFFFFL); // Bit mask for input value (controls sign-extend)
    if (dSize == 24) {
      if (delta == 3) {
        for (int i = 0; i < length; i++,off+=3) {
          int val = (int)(((int)array[offset++]) & valMask);
          packInt24(buf, off, val);
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          int val = (int)(((int)array[offset++]) & valMask);
          packInt24(buf, off, val);
          off += 3;
          for (int j = 3; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
    else {
      int shift = 24 - dSize;
      if (delta == 3) {
        for (int i = 0; i < length; i++,off+=3) {
          int val = (int)(((int)array[offset++]) & valMask);
          packInt24(buf, off, (int)(val << shift));
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          int val = (int)(((int)array[offset++]) & valMask);
          packInt24(buf, off, (int)(val << shift));
          off += 3;
          for (int j = 3; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for signed short data.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void unpackShorts (byte[] buf, int off, short[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = fSize / 8; // byte offset delta
    if (sign) {
      if (dSize == 16) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (short)unpackShort(buf, off);
        }
      }
      else {
        int shift  = 16 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (short)(unpackShort(buf, off) >> shift);
        }
      }
    }
    else {
      if (dSize == 16) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (short)(unpackShort(buf, off) & 0xFFFF);
        }
      }
      else {
        int shift  = 16 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (short)((unpackShort(buf, off) & 0xFFFF) >>> shift);
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast pack method for unsigned short data.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void packShorts (byte[] buf, int off, short[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = fSize / 8; // byte offset delta
    short valMask = (sign)? ((short)-1) : ((short)0xFFFFL); // Bit mask for input value (controls sign-extend)
    if (dSize == 16) {
      if (delta == 2) {
        for (int i = 0; i < length; i++,off+=2) {
          short val = (short)(((short)array[offset++]) & valMask);
          packShort(buf, off, val);
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          short val = (short)(((short)array[offset++]) & valMask);
          packShort(buf, off, val);
          off += 2;
          for (int j = 2; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
    else {
      int shift = 16 - dSize;
      if (delta == 2) {
        for (int i = 0; i < length; i++,off+=2) {
          short val = (short)(((short)array[offset++]) & valMask);
          packShort(buf, off, (short)(val << shift));
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          short val = (short)(((short)array[offset++]) & valMask);
          packShort(buf, off, (short)(val << shift));
          off += 2;
          for (int j = 2; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for signed Int12 data.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
   *  @param fSize  (IN)  Item packing field size in bits (must be 12)
   *  @param dSize  (IN)  Data item size in bits (must be 12)
   *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackInt12s (byte[] buf, int off, short[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int skip = (align)? 1 : 0;
    if (sign) {
      for (int i = 0; i < length; i+=2) {
        int a = (int)buf[off++];
        int b = (int)buf[off++];
        int c = (int)buf[off++];
        int x = (a << 4) | ((b >> 4) & 0x000F);
        int y = (b << 8) | ((c     ) & 0x00FF);
        array[offset++] = (short)((x << 20) >> 20); // sign extend
        array[offset++] = (short)((y << 20) >> 20); // sign extend
        off += skip; // skip extra byte in processing-efficient mode
      }
    }
    else {
      for (int i = 0; i < length; i+=2) {
        int a = (int)buf[off++];
        int b = (int)buf[off++];
        int c = (int)buf[off++];
        int x = (a << 4) | ((b >> 4) & 0x000F);
        int y = (b << 8) | ((c     ) & 0x00FF);
        array[offset++] = (short)(x & 0x0FFF); // clear high-order bits
        array[offset++] = (short)(y & 0x0FFF); // clear high-order bits
        off += skip; // skip extra byte in processing-efficient mode
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast pack method for signed Int12 data.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
   *  @param fSize  (IN)  Item packing field size in bits (must be 12)
   *  @param dSize  (IN)  Data item size in bits (must be 12)
   *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packInt12s (byte[] buf, int off, short[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int skip = (align)?  1 : 0;
    int mask = (sign )? -1 : ((int)0xFFFFL);
    for (int i = 0; i < length; i+=2) {
      int first  = ((int)array[offset++]) & mask;
      int second = ((int)array[offset++]) & mask;
      buf[off++] = (byte)(first >> 4);
      buf[off++] = (byte)((first << 4) | ((second >> 8) & 0x0F));
      buf[off++] = (byte)(second);
      off += skip; // skip extra byte in processing-efficient mode
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for signed byte data.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void unpackBytes (byte[] buf, int off, short[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = fSize / 8; // byte offset delta
    if (sign) {
      if (dSize == 8) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (short)unpackByte(buf, off);
        }
      }
      else {
        int shift  = 8 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (short)(unpackByte(buf, off) >> shift);
        }
      }
    }
    else {
      if (dSize == 8) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (short)(unpackByte(buf, off) & 0xFF);
        }
      }
      else {
        int shift  = 8 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (short)((unpackByte(buf, off) & 0xFF) >>> shift);
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast pack method for unsigned byte data.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void packBytes (byte[] buf, int off, short[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = fSize / 8; // byte offset delta
    byte valMask = (sign)? ((byte)-1) : ((byte)0xFFFFL); // Bit mask for input value (controls sign-extend)
    if (dSize == 8) {
      if (delta == 1) {
        for (int i = 0; i < length; i++,off+=1) {
          byte val = (byte)(((byte)array[offset++]) & valMask);
          packByte(buf, off, val);
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          byte val = (byte)(((byte)array[offset++]) & valMask);
          packByte(buf, off, val);
          off += 1;
          for (int j = 1; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
    else {
      int shift = 8 - dSize;
      if (delta == 1) {
        for (int i = 0; i < length; i++,off+=1) {
          byte val = (byte)(((byte)array[offset++]) & valMask);
          packByte(buf, off, (byte)(val << shift));
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          byte val = (byte)(((byte)array[offset++]) & valMask);
          packByte(buf, off, (byte)(val << shift));
          off += 1;
          for (int j = 1; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for signed Int4 (nibble) data.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
   *  @param fSize  (IN)  Item packing field size in bits (must be 4)
   *  @param dSize  (IN)  Data item size in bits (must be 4)
   *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackNibbles (byte[] buf, int off, short[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    if (sign) {
      for (int i = 0; i < length; i+=2) {
        int b = (int)buf[off++];
        array[offset++] = (short)((b << 24) >> 28); // shift & sign extend
        array[offset++] = (short)((b << 28) >> 28); // shift & sign extend
      }
    }
    else {
      for (int i = 0; i < length; i+=2) {
        int b = (int)buf[off++];
        array[offset++] = (short)((b >> 4) & 0xF);
        array[offset++] = (short)((b     ) & 0xF);
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast pack method for signed Int4 (nibble) data.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
   *  @param fSize  (IN)  Item packing field size in bits (must be 4)
   *  @param dSize  (IN)  Data item size in bits (must be 4)
   *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packNibbles (byte[] buf, int off, short[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    // Pack function for signed and are identical for nibble data, hence
    // 'sign' is unused here, but included in function definition for consistency.
    for (int i = 0; i < length; i+=2) {
      int first  = (int)array[offset++];
      int second = (int)array[offset++];
      buf[off++] = (byte)((first << 4) | (second & 0xF));
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for bit data. Each bit in the
   *  input buffer will be checked, a 0 bit will correspond to the value 0 and a
   *  1 bit will correspond to the value 1.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert (must be a multiple of 8)
   *  @param fSize  (IN)  Item packing field size in bits (must be 1)
   *  @param dSize  (IN)  Data item size in bits (must be 1)
   *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackBits (byte[] buf, int off, short[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    if (sign) {
      // This uses sign-extending principles to get each bit as 0 or -1 which reflects
      // the fact that 0/-1 and not 0/+1 are the available values in a one-bit use of
      // twos-complement.
      for (int i = 0; i < length; i+=8) {
        int b = (int)buf[off++];
        array[offset++] = (short)((b << 24) >> 31);
        array[offset++] = (short)((b << 25) >> 31);
        array[offset++] = (short)((b << 26) >> 31);
        array[offset++] = (short)((b << 27) >> 31);
        array[offset++] = (short)((b << 28) >> 31);
        array[offset++] = (short)((b << 29) >> 31);
        array[offset++] = (short)((b << 30) >> 31);
        array[offset++] = (short)((b << 31) >> 31);
      }
    }
    else {
      for (int i = 0; i < length; i+=8) {
        int b = (int)buf[off++];
        array[offset++] = (short)((b >> 7) & 0x1);
        array[offset++] = (short)((b >> 6) & 0x1);
        array[offset++] = (short)((b >> 5) & 0x1);
        array[offset++] = (short)((b >> 4) & 0x1);
        array[offset++] = (short)((b >> 3) & 0x1);
        array[offset++] = (short)((b >> 2) & 0x1);
        array[offset++] = (short)((b >> 1) & 0x1);
        array[offset++] = (short)((b     ) & 0x1);
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast pack method for bit data. Each value in the
   *  input array will be checked, a zero value will correspond to the bit 0 and
   *  any non-zero value will correspond to the bit 1.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert (must be a multiple of 8)
   *  @param fSize  (IN)  Item packing field size in bits (must be 1)
   *  @param dSize  (IN)  Data item size in bits (must be 1)
   *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packBits (byte[] buf, int off, short[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    // Pack function for signed and are identical for bit data, hence
    // 'sign' is unused here, but included in function definition for consistency.
    for (int i = 0; i < length; i+=8) {
      int b = 0;
      b |= (((int)array[offset++]) << 7) & 0x80;
      b |= (((int)array[offset++]) << 6) & 0x40;
      b |= (((int)array[offset++]) << 5) & 0x20;
      b |= (((int)array[offset++]) << 4) & 0x10;
      b |= (((int)array[offset++]) << 3) & 0x08;
      b |= (((int)array[offset++]) << 2) & 0x04;
      b |= (((int)array[offset++]) << 1) & 0x02;
      b |= (((int)array[offset++])     ) & 0x01;
      buf[off++] = (byte)b;
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array, where the data is
   *  aligned to 32-bit word boundaries.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array  (OUT) Output value array (not null)
   *  @param chan   (OUT) Output channel tag array (null if n/a)
   *  @param evt    (OUT) Output event tag array (null if n/a)
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits
   *  @param dSize  (IN)  Data item size in bits
   *  @param eSize  (IN)  Event tag size in bits
   *  @param cSize  (IN)  Channel tag size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackIntWord32 (byte[] buf, int off, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+- - - - - +
    //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
    //   +-----------+--------+-----------+-------------+- - - - - +
    //       dSize      uSize     eSize       cSize        pSize
    //   |------------------ fSize ---------------------|
    //   |---------------------- Word Size ------------------------|
    int    pSize    = 32 - fSize;
    int    evtMask  = ~(((int)-1) << eSize);
    int    chanMask = ~(((int)-1) << cSize);
    int valMask  = (sign)? ((int)-1) : (~(((int)-1) << dSize));
    for (int i = 0; i < length; i++,off+=4) {
      int value = unpackInt(buf, off);
      array[i] = (short)((value >> (32-dSize)) & valMask);
      if (chan != null) chan[i] = (value >> (pSize      )) & chanMask;
      if (evt  != null) evt[i]  = (value >> (pSize+cSize)) & evtMask;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array, where the data is
   *  aligned to 32-bit word boundaries.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input value array
   *  @param chan   (IN)  Input channel tag array (null if n/a)
   *  @param evt    (IN)  Input event tag array (null if n/a)
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits
   *  @param dSize  (IN)  Data item size in bits
   *  @param eSize  (IN)  Event tag size in bits
   *  @param cSize  (IN)  Channel tag size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packIntWord32 (byte[] buf, int off, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+- - - - - +
    //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
    //   +-----------+--------+-----------+-------------+- - - - - +
    //       dSize      uSize     eSize       cSize        pSize
    //   |------------------ fSize ---------------------|
    //   |---------------------- Word Size ------------------------|
    int    pSize    = 32 - fSize;
    int    evtMask  = ~(((int)-1) << eSize);
    int    chanMask = ~(((int)-1) << cSize);
    int valMask  = (sign)? ((int)-1) : ((int)0xFFFFL);
    for (int i = 0; i < length; i++,off+=4) {
      int val   = (int)(((int)array[i]) & valMask);
      int value = val << (32-dSize);
      if (chan != null) value |= (chan[i] & chanMask) << (pSize);
      if (evt  != null) value |= (evt[i]  & evtMask ) << (pSize+cSize);
      packInt(buf, off, value);
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array, where the data is
   *  aligned to 64-bit word boundaries.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array  (OUT) Output value array (not null)
   *  @param chan   (OUT) Output channel tag array (null if n/a)
   *  @param evt    (OUT) Output event tag array (null if n/a)
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits
   *  @param dSize  (IN)  Data item size in bits
   *  @param eSize  (IN)  Event tag size in bits
   *  @param cSize  (IN)  Channel tag size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackIntWord64 (byte[] buf, int off, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+- - - - - +
    //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
    //   +-----------+--------+-----------+-------------+- - - - - +
    //       dSize      uSize     eSize       cSize        pSize
    //   |------------------ fSize ---------------------|
    //   |---------------------- Word Size ------------------------|
    int    pSize    = 64 - fSize;
    int    evtMask  = ~(((int)-1) << eSize);
    int    chanMask = ~(((int)-1) << cSize);
    long valMask  = (sign)? ((long)-1) : (~(((long)-1) << dSize));
    if (dSize == 32) {
      // When using Int32/UInt32 the first 32-bits will always the the Int32/UInt32
      // value, so use 32-bit operations to improve performance
      for (int i = 0; i < length; i++,off+=8) {
        int val   = unpackInt(buf, off);
        int value = unpackInt(buf, off+4);
        array[i] = (short)(val & valMask);
        if (chan != null) chan[i] = ((int)(value >> (pSize      ))) & chanMask;
        if (evt  != null) evt[i]  = ((int)(value >> (pSize+cSize))) & evtMask;
      }
    }
    else {
      for (int i = 0; i < length; i++,off+=8) {
        long value = unpackLong(buf, off);
        array[i] = (short)((value >> (64-dSize)) & valMask);
        if (chan != null) chan[i] = ((int)(value >> (pSize      ))) & chanMask;
        if (evt  != null) evt[i]  = ((int)(value >> (pSize+cSize))) & evtMask;
      }
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array, where the data is
   *  aligned to 64-bit word boundaries.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input value array
   *  @param chan   (IN)  Input channel tag array (null if n/a)
   *  @param evt    (IN)  Input event tag array (null if n/a)
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits
   *  @param dSize  (IN)  Data item size in bits
   *  @param eSize  (IN)  Event tag size in bits
   *  @param cSize  (IN)  Channel tag size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packIntWord64 (byte[] buf, int off, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+- - - - - +
    //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
    //   +-----------+--------+-----------+-------------+- - - - - +
    //       dSize      uSize     eSize       cSize        pSize
    //   |------------------ fSize ---------------------|
    //   |---------------------- Word Size ------------------------|
    int    pSize    = 64 - fSize;
    int    evtMask  = ~(((int)-1) << eSize);
    int    chanMask = ~(((int)-1) << cSize);
    long valMask  = (sign)? ((long)-1) : ((long)0xFFFFL);
    if (dSize == 32) {
      // When using Int32/UInt32 the first 32-bits will always the the Int32/UInt32
      // value, so use 32-bit operations to improve performance
      for (int i = 0; i < length; i++,off+=8) {
        int val   = (int)(((long)array[i]) & valMask);
        int value = 0;
        if (chan != null) value  = (chan[i] & chanMask) << (pSize);
        if (evt  != null) value |= (evt[i]  & evtMask ) << (pSize+cSize);
        packInt(buf, off,   val);
        packInt(buf, off+4, value);
      }
    }
    else {
      for (int i = 0; i < length; i++,off+=8) {
        long val   = (long)(((long)array[i]) & valMask);
        long value = val << (64-dSize);
        if (chan != null) value |= ((long)(chan[i] & chanMask)) << (pSize);
        if (evt  != null) value |= ((long)(evt[i]  & evtMask )) << (pSize+cSize);
        packLong(buf, off, value);
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array, where the data is
   *  aligned to 64-bit word boundaries.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array  (OUT) Output value array (not null)
   *  @param chan   (OUT) Output channel tag array (null if n/a)
   *  @param evt    (OUT) Output event tag array (null if n/a)
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits
   *  @param dSize  (IN)  Data item size in bits
   *  @param eSize  (IN)  Event tag size in bits
   *  @param cSize  (IN)  Channel tag size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackFloatWord64 (byte[] buf, int off, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+- - - - - +
    //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
    //   +-----------+--------+-----------+-------------+- - - - - +
    //       dSize      uSize     eSize       cSize        pSize
    //   |------------------ fSize ---------------------|
    //   |---------------------- Word Size ------------------------|
    int    pSize    = 64 - fSize;
    int    evtMask  = ~(((int)-1) << eSize);
    int    chanMask = ~(((int)-1) << cSize);
    // When using Float32 the first 32-bits will always the the Float32 value, so
    // use 32-bit operations to improve performance
    for (int i = 0; i < length; i++,off+=8) {
      array[i] = (short)unpackFloat(buf, off);
      int value = unpackInt(buf, off+4);
      if (chan != null) chan[i] = (value >> (pSize      )) & chanMask;
      if (evt  != null) evt[i]  = (value >> (pSize+cSize)) & evtMask;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array, where the data is
   *  aligned to 64-bit word boundaries.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input value array
   *  @param chan   (IN)  Input channel tag array (null if n/a)
   *  @param evt    (IN)  Input event tag array (null if n/a)
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits
   *  @param dSize  (IN)  Data item size in bits
   *  @param eSize  (IN)  Event tag size in bits
   *  @param cSize  (IN)  Channel tag size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packFloatWord64 (byte[] buf, int off, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+- - - - - +
    //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
    //   +-----------+--------+-----------+-------------+- - - - - +
    //       dSize      uSize     eSize       cSize        pSize
    //   |------------------ fSize ---------------------|
    //   |---------------------- Word Size ------------------------|
    int    pSize    = 64 - fSize;
    int    evtMask  = ~(((int)-1) << eSize);
    int    chanMask = ~(((int)-1) << cSize);
    // When using Float32 the first 32-bits will always the the Float32 value, so
    // use 32-bit operations to improve performance
    for (int i = 0; i < length; i++,off+=8) {
      float val   = (float)array[i];
      int   value = 0;
      if (chan != null) value  = (chan[i] & chanMask) << (pSize);
      if (evt  != null) value |= (evt[i]  & evtMask ) << (pSize+cSize);
      packFloat(buf, off,   val);
      packInt(  buf, off+4, value);
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackIntBuffer32 (byte[] buf, int bitOffset, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_dSize  = 32 - dSize;    // pre-compute "32 - dSize" for efficiency
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        if (sign) {
          // sign extend
          array[offset] = (short)((value << _bits_dSize) >>  _bits_dSize);
        }
        else {
          // leave top bits (which default to 0) as 0
          array[offset] = (short)value;
        }
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packIntBuffer32 (byte[] buf, int bitOffset, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    int valMask      = (sign)? ((int)-1) : ((int)0xFFFFL); // Bit mask for input value (controls sign-extend)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        int arrayValue = ((int)array[offset]) & valMask;
        int value      = (int)((arrayValue) << (32 - dSize));
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackIntBuffer64 (byte[] buf, int bitOffset, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_dSize  = 64 - dSize;    // pre-compute "64 - dSize" for efficiency
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        if (sign) {
          // sign extend
          array[offset] = (short)((value << _bits_dSize) >>  _bits_dSize);
        }
        else {
          // leave top bits (which default to 0) as 0
          array[offset] = (short)value;
        }
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packIntBuffer64 (byte[] buf, int bitOffset, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    long valMask      = (sign)? ((long)-1) : ((long)0xFFFFL); // Bit mask for input value (controls sign-extend)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        long arrayValue = ((long)array[offset]) & valMask;
        long value      = (long)((arrayValue) << (64 - dSize));
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackFloatBuffer64 (byte[] buf, int bitOffset, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (short)intBitsToFloat((int)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packFloatBuffer64 (byte[] buf, int bitOffset, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        float  arrayValue = (float)array[offset];
        long   value      = ((long)floatToRawIntBits(arrayValue)) << 32;
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT1Buffer32 (byte[] buf, int bitOffset, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (short)fromVRTFloat(DataItemFormat.SignedVRT1, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT1Buffer32 (byte[] buf, int bitOffset, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.SignedVRT1, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT1Buffer64 (byte[] buf, int bitOffset, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (short)fromVRTFloat(DataItemFormat.SignedVRT1, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT1Buffer64 (byte[] buf, int bitOffset, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.SignedVRT1, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT2Buffer32 (byte[] buf, int bitOffset, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (short)fromVRTFloat(DataItemFormat.SignedVRT2, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT2Buffer32 (byte[] buf, int bitOffset, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.SignedVRT2, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT2Buffer64 (byte[] buf, int bitOffset, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (short)fromVRTFloat(DataItemFormat.SignedVRT2, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT2Buffer64 (byte[] buf, int bitOffset, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.SignedVRT2, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT3Buffer32 (byte[] buf, int bitOffset, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (short)fromVRTFloat(DataItemFormat.SignedVRT3, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT3Buffer32 (byte[] buf, int bitOffset, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.SignedVRT3, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT3Buffer64 (byte[] buf, int bitOffset, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (short)fromVRTFloat(DataItemFormat.SignedVRT3, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT3Buffer64 (byte[] buf, int bitOffset, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.SignedVRT3, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT4Buffer32 (byte[] buf, int bitOffset, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (short)fromVRTFloat(DataItemFormat.SignedVRT4, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT4Buffer32 (byte[] buf, int bitOffset, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.SignedVRT4, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT4Buffer64 (byte[] buf, int bitOffset, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (short)fromVRTFloat(DataItemFormat.SignedVRT4, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT4Buffer64 (byte[] buf, int bitOffset, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.SignedVRT4, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT5Buffer32 (byte[] buf, int bitOffset, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (short)fromVRTFloat(DataItemFormat.SignedVRT5, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT5Buffer32 (byte[] buf, int bitOffset, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.SignedVRT5, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT5Buffer64 (byte[] buf, int bitOffset, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (short)fromVRTFloat(DataItemFormat.SignedVRT5, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT5Buffer64 (byte[] buf, int bitOffset, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.SignedVRT5, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT6Buffer32 (byte[] buf, int bitOffset, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (short)fromVRTFloat(DataItemFormat.SignedVRT6, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT6Buffer32 (byte[] buf, int bitOffset, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.SignedVRT6, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT6Buffer64 (byte[] buf, int bitOffset, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (short)fromVRTFloat(DataItemFormat.SignedVRT6, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT6Buffer64 (byte[] buf, int bitOffset, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.SignedVRT6, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT1Buffer32 (byte[] buf, int bitOffset, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (short)fromVRTFloat(DataItemFormat.UnsignedVRT1, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT1Buffer32 (byte[] buf, int bitOffset, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.UnsignedVRT1, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT1Buffer64 (byte[] buf, int bitOffset, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (short)fromVRTFloat(DataItemFormat.UnsignedVRT1, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT1Buffer64 (byte[] buf, int bitOffset, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.UnsignedVRT1, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT2Buffer32 (byte[] buf, int bitOffset, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (short)fromVRTFloat(DataItemFormat.UnsignedVRT2, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT2Buffer32 (byte[] buf, int bitOffset, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.UnsignedVRT2, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT2Buffer64 (byte[] buf, int bitOffset, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (short)fromVRTFloat(DataItemFormat.UnsignedVRT2, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT2Buffer64 (byte[] buf, int bitOffset, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.UnsignedVRT2, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT3Buffer32 (byte[] buf, int bitOffset, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (short)fromVRTFloat(DataItemFormat.UnsignedVRT3, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT3Buffer32 (byte[] buf, int bitOffset, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.UnsignedVRT3, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT3Buffer64 (byte[] buf, int bitOffset, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (short)fromVRTFloat(DataItemFormat.UnsignedVRT3, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT3Buffer64 (byte[] buf, int bitOffset, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.UnsignedVRT3, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT4Buffer32 (byte[] buf, int bitOffset, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (short)fromVRTFloat(DataItemFormat.UnsignedVRT4, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT4Buffer32 (byte[] buf, int bitOffset, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.UnsignedVRT4, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT4Buffer64 (byte[] buf, int bitOffset, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (short)fromVRTFloat(DataItemFormat.UnsignedVRT4, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT4Buffer64 (byte[] buf, int bitOffset, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.UnsignedVRT4, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT5Buffer32 (byte[] buf, int bitOffset, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (short)fromVRTFloat(DataItemFormat.UnsignedVRT5, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT5Buffer32 (byte[] buf, int bitOffset, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.UnsignedVRT5, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT5Buffer64 (byte[] buf, int bitOffset, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (short)fromVRTFloat(DataItemFormat.UnsignedVRT5, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT5Buffer64 (byte[] buf, int bitOffset, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.UnsignedVRT5, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT6Buffer32 (byte[] buf, int bitOffset, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (short)fromVRTFloat(DataItemFormat.UnsignedVRT6, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT6Buffer32 (byte[] buf, int bitOffset, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.UnsignedVRT6, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT6Buffer64 (byte[] buf, int bitOffset, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (short)fromVRTFloat(DataItemFormat.UnsignedVRT6, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT6Buffer64 (byte[] buf, int bitOffset, short[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.UnsignedVRT6, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Unpacks values with the given format specifier as
   *  an array of <tt>short</tt>. <br>
   *  <br>
   *  Setting the channel tags (<tt>chan</tt>) and/or event tags (<tt>evt</tt>)
   *  arrays to null will cause any channel or event tags present to be ignored.
   *  In most cases this results in a performance improvement. <br>
   *  <br>
   *  If the channel tags (<tt>chan</tt>) and/or event tags (<tt>evt</tt>) arrays
   *  are non-null when there are no channel or event tags present, the values in
   *  the arrays will not be modified.
   *  @param pf     (IN)  The data format
   *  @param buf    (IN)  The buffer
   *  @param off    (IN)  The buffer offset
   *  @param array  (OUT) The output array for the values
   *  @param chan   (OUT) The output array for the channel tags (null if n/a)
   *  @param evt    (OUT) The output array for the event tags (null if n/a)
   *  @param length (IN)  Number of elements to convert
   *  @return The output array (same as <tt>array</tt>).
   */
  @SuppressWarnings("fallthrough")
  public static short[] unpackAsShort (PayloadFormat pf, byte[] buf, int off, short[] array, int[] chan, int[] evt, int length) {
    if (!pf.isValid()) {
      throw new IllegalArgumentException(pf.getValid());
    }
    int            fSize  = pf.getItemPackingFieldSize();
    int            dSize  = pf.getDataItemSize();
    int            eSize  = pf.getEventTagSize();
    int            cSize  = pf.getChannelTagSize();
    boolean        proc   = pf.isProcessingEfficient();
    boolean        sign   = pf.isSigned();
    DataItemFormat format = pf.getDataItemFormat();
    boolean        noTags;
    if (eSize == 0) evt  = null; // no event tags, ignore any array passed in
    if (cSize == 0) chan = null; // no channel tags, ignore any array passed in
    noTags = (chan == null) && (evt == null);
    if (proc && noTags && (fSize >= 17)) {
      // Use faster "effective field size" when ignoring Event & Channel Tags
      fSize = (fSize <= 32)? 32 : 64;
    }
    switch (format) {
      case SignedInt:   // FALLTHROUGH
      case UnsignedInt:
        // ---- Try fast methods -------------------------------------------------
        if (noTags) {
          switch (fSize) {
            case  8: unpackBytes(  buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
            case 16: unpackShorts( buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
            case 24: unpackInt24s( buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
            case 32: unpackInts(   buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
            case 64: unpackLongs(  buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
          }
        }
        if (fSize == dSize) { // implicit noTags=true in this case
          switch (fSize) {
            case  1: if ((length % 8) == 0) { unpackBits(   buf, off, array, 0, length, fSize, dSize, proc, sign); return array; } break;
            case  4: if ((length % 2) == 0) { unpackNibbles(buf, off, array, 0, length, fSize, dSize, proc, sign); return array; } break;
            case 12: if ((length % 2) == 0) { unpackInt12s( buf, off, array, 0, length, fSize, dSize, proc, sign); return array; } break;
          }
        }
        if ((proc && (fSize >= 17)) || (fSize == 32) || (fSize == 64)) {
          if (fSize <= 32) {
            unpackIntWord32(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
          }
          else {
            unpackIntWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
          }
        }
        // ---- Fall back to slow method -----------------------------------------
        if (fSize <= 32) {
          unpackIntBuffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackIntBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case Float:
        // ---- Try fast methods -------------------------------------------------
        if (fSize == dSize) { // implicit noTags=true in this case
          unpackFloats(buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
        }
        if ((proc && (fSize >= 33)) || (fSize == 64)) {
          unpackFloatWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        // ---- Fall back to slow method -----------------------------------------
        unpackFloatBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      case Double:
        // ---- Only fast method for double (yea!) -------------------------------
        unpackDoubles(buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
      case SignedVRT1:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackSignedVRT1Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackSignedVRT1Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case SignedVRT2:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackSignedVRT2Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackSignedVRT2Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case SignedVRT3:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackSignedVRT3Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackSignedVRT3Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case SignedVRT4:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackSignedVRT4Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackSignedVRT4Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case SignedVRT5:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackSignedVRT5Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackSignedVRT5Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case SignedVRT6:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackSignedVRT6Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackSignedVRT6Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case UnsignedVRT1:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackUnsignedVRT1Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackUnsignedVRT1Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case UnsignedVRT2:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackUnsignedVRT2Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackUnsignedVRT2Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case UnsignedVRT3:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackUnsignedVRT3Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackUnsignedVRT3Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case UnsignedVRT4:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackUnsignedVRT4Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackUnsignedVRT4Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case UnsignedVRT5:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackUnsignedVRT5Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackUnsignedVRT5Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case UnsignedVRT6:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackUnsignedVRT6Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackUnsignedVRT6Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      default:
        throw new UnsupportedOperationException("Unpacking of VRT float types not supported yet");
    }
  }
  /** <b>Internal Use Only:</b> Packs values with the given format specifier from
   *  an array of short. <br>
   *  <br>
   *  Setting the channel tags (<tt>chan</tt>) and/or event tags (<tt>evt</tt>)
   *  arrays to null will cause any channel or event tags present to be set to
   *  zero. In most cases this results in a performance improvement over passing
   *  in an array of zeros. <br>
   *  <br>
   *  If the channel tags (<tt>chan</tt>) and/or event tags (<tt>evt</tt>) arrays
   *  are non-null when there are no channel or event tags present, the values in
   *  the arrays will be ignored.
   *  @param pf     (IN)  The data format
   *  @param buf    (I/O) The buffer
   *  @param off    (IN)  The buffer offset
   *  @param array  (IN)  The values to pack
   *  @param chan   (OUT) The output array for the channel tags (null if n/a)
   *  @param evt    (OUT) The output array for the event tags (null if n/a)
   *  @param length (IN)  Number of elements to convert
   */
  @SuppressWarnings("fallthrough")
  public static void packAsShort (PayloadFormat pf, byte[] buf, int off, short[] array, int[] chan, int[] evt, int length) {
    if (!pf.isValid()) {
      throw new IllegalArgumentException(pf.getValid());
    }
    int            fSize  = pf.getItemPackingFieldSize();
    int            dSize  = pf.getDataItemSize();
    int            eSize  = pf.getEventTagSize();
    int            cSize  = pf.getChannelTagSize();
    boolean        proc   = pf.isProcessingEfficient();
    boolean        sign   = pf.isSigned();
    DataItemFormat format = pf.getDataItemFormat();
    boolean        noTags;
    if (eSize == 0) evt  = null; // no event tags, ignore any array passed in
    if (cSize == 0) chan = null; // no channel tags, ignore any array passed in
    noTags = (chan == null) && (evt == null);
    if (proc && noTags && (fSize >= 17)) {
      // Use faster "effective field size" when ignoring Event & Channel Tags
      fSize = (fSize <= 32)? 32 : 64;
    }
    switch (format) {
      case SignedInt:   // FALLTHROUGH
      case UnsignedInt:
        // ---- Try fast methods -------------------------------------------------
        if (noTags) {
          switch (fSize) {
            case  8: packBytes(  buf, off, array, 0, length, fSize, dSize, proc, sign); return;
            case 16: packShorts( buf, off, array, 0, length, fSize, dSize, proc, sign); return;
            case 24: packInt24s( buf, off, array, 0, length, fSize, dSize, proc, sign); return;
            case 32: packInts(   buf, off, array, 0, length, fSize, dSize, proc, sign); return;
            case 64: packLongs(  buf, off, array, 0, length, fSize, dSize, proc, sign); return;
          }
        }
        if (fSize == dSize) { // implicit noTags=true in this case
          switch (fSize) {
            case  1: if ((length % 8) == 0) { packBits(   buf, off, array, 0, length, fSize, dSize, proc, sign); return; } break;
            case  4: if ((length % 2) == 0) { packNibbles(buf, off, array, 0, length, fSize, dSize, proc, sign); return; } break;
            case 12: if ((length % 2) == 0) { packInt12s( buf, off, array, 0, length, fSize, dSize, proc, sign); return; } break;
          }
        }
        if ((proc && (fSize >= 17)) || (fSize == 32) || (fSize == 64)) {
          if (fSize <= 32) {
            packIntWord32(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
          }
          else {
            packIntWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
          }
        }
        // ---- Fall back to slow method -----------------------------------------
        if (fSize <= 32) {
          packIntBuffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packIntBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case Float:
        // ---- Try fast methods -------------------------------------------------
        if (fSize == dSize) { // implicit noTags=true in this case
          packFloats(buf, off, array, 0, length, fSize, dSize, proc, sign); return;
        }
        if ((proc && (fSize >= 33)) || (fSize == 64)) {
          packFloatWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        // ---- Fall back to slow method -----------------------------------------
        packFloatBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      case Double:
        // ---- Only fast method for double (yea!) -------------------------------
        packDoubles(buf, off, array, 0, length, fSize, dSize, proc, sign); return;
      case SignedVRT1:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packSignedVRT1Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packSignedVRT1Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case SignedVRT2:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packSignedVRT2Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packSignedVRT2Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case SignedVRT3:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packSignedVRT3Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packSignedVRT3Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case SignedVRT4:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packSignedVRT4Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packSignedVRT4Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case SignedVRT5:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packSignedVRT5Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packSignedVRT5Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case SignedVRT6:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packSignedVRT6Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packSignedVRT6Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case UnsignedVRT1:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packUnsignedVRT1Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packUnsignedVRT1Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case UnsignedVRT2:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packUnsignedVRT2Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packUnsignedVRT2Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case UnsignedVRT3:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packUnsignedVRT3Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packUnsignedVRT3Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case UnsignedVRT4:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packUnsignedVRT4Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packUnsignedVRT4Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case UnsignedVRT5:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packUnsignedVRT5Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packUnsignedVRT5Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case UnsignedVRT6:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packUnsignedVRT6Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packUnsignedVRT6Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      default:
        throw new UnsupportedOperationException("Packing of VRT float types not supported yet");
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for double data.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits (must be 64)
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed? (must be true)
   */
  @SuppressWarnings("cast")
  private static  void unpackDoubles (byte[] buf, int off, byte[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    // All floating-point values are signed, so 'sign' is unused, but is included
    // in function definition for consistency.
    // When using Double data, it is required that dSize=64 and fSize=64 so we can
    // skip some of the normal checks we would otherwise do here.
    for (int i = 0; i < length; i++,off+=8) {
      array[offset++] = (byte)unpackDouble(buf, off);
    }
  }
  /** <b>Internal Use Only:</b>
   *  Fast pack method for double data.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits (must be 64)
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed? (must be true)
   */
  @SuppressWarnings("cast")
  private static  void packDoubles (byte[] buf, int off, byte[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    // All floating-point values are signed, so 'sign' is unused, but is included
    // in function definition for consistency.
    // When using Double data, it is required that dSize=64 and fSize=64 so we can
    // skip some of the normal checks we would otherwise do here.
    for (int i = 0; i < length; i++,off+=8) {
      packDouble(buf, off, (double)array[offset++]);
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for float data.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits (must be 32)
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed? (must be true)
   */
  @SuppressWarnings("cast")
  private static  void unpackFloats (byte[] buf, int off, byte[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    // All floating-point values are signed, so 'sign' is unused, but is included
    // in function definition for consistency.
    int delta; // byte offset delta
    if (align) delta = (fSize <= 32)? 4 : 8;
    else       delta = fSize / 8;
    for (int i = 0; i < length; i++,off+=delta) {
      array[offset++] = (byte)unpackFloat(buf, off);
    }
  }
  /** <b>Internal Use Only:</b>
   *  Fast pack method for float data.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits (must be 32)
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed? (must be true)
   */
  @SuppressWarnings("cast")
  private static  void packFloats (byte[] buf, int off, byte[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    // All floating-point values are signed, so 'sign' is unused, but is included
    // in function definition for consistency.
    int delta; // byte offset delta
    if (align) delta = (fSize <= 32)? 4 : 8;
    else       delta = fSize / 8;
    if (delta == 4) {
      for (int i = 0; i < length; i++,off+=4) {
        packFloat(buf, off, (float)array[offset++]);
      }
    }
    else {
      for (int i = 0; i < length; i++) {
        packFloat(buf, off, (float)array[offset++]);
        off += 4;
        for (int j = 4; j < delta; j++) {
          buf[off++] = 0; // set unused bits to zero
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for signed long data.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void unpackLongs (byte[] buf, int off, byte[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // byte offset delta
    if (sign) {
      if (dSize == 64) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (byte)unpackLong(buf, off);
        }
      }
      else {
        int shift  = 64 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (byte)(unpackLong(buf, off) >> shift);
        }
      }
    }
    else {
      if (dSize == 64) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (byte)(unpackLong(buf, off) & 0xFFFFFFFFFFFFFFFFL);
        }
      }
      else {
        int shift  = 64 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (byte)((unpackLong(buf, off) & 0xFFFFFFFFFFFFFFFFL) >>> shift);
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast pack method for unsigned long data.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void packLongs (byte[] buf, int off, byte[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // byte offset delta
    long valMask = (sign)? ((long)-1) : ((long)0xFFL); // Bit mask for input value (controls sign-extend)
    if (dSize == 64) {
      if (delta == 8) {
        for (int i = 0; i < length; i++,off+=8) {
          long val = (long)(((long)array[offset++]) & valMask);
          packLong(buf, off, val);
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          long val = (long)(((long)array[offset++]) & valMask);
          packLong(buf, off, val);
          off += 8;
          for (int j = 8; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
    else {
      int shift = 64 - dSize;
      if (delta == 8) {
        for (int i = 0; i < length; i++,off+=8) {
          long val = (long)(((long)array[offset++]) & valMask);
          packLong(buf, off, (long)(val << shift));
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          long val = (long)(((long)array[offset++]) & valMask);
          packLong(buf, off, (long)(val << shift));
          off += 8;
          for (int j = 8; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for signed int data.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void unpackInts (byte[] buf, int off, byte[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // byte offset delta
    if (sign) {
      if (dSize == 32) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (byte)unpackInt(buf, off);
        }
      }
      else {
        int shift  = 32 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (byte)(unpackInt(buf, off) >> shift);
        }
      }
    }
    else {
      if (dSize == 32) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (byte)(unpackInt(buf, off) & 0xFFFFFFFF);
        }
      }
      else {
        int shift  = 32 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (byte)((unpackInt(buf, off) & 0xFFFFFFFF) >>> shift);
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast pack method for unsigned int data.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void packInts (byte[] buf, int off, byte[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // byte offset delta
    int valMask = (sign)? ((int)-1) : ((int)0xFFL); // Bit mask for input value (controls sign-extend)
    if (dSize == 32) {
      if (delta == 4) {
        for (int i = 0; i < length; i++,off+=4) {
          int val = (int)(((int)array[offset++]) & valMask);
          packInt(buf, off, val);
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          int val = (int)(((int)array[offset++]) & valMask);
          packInt(buf, off, val);
          off += 4;
          for (int j = 4; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
    else {
      int shift = 32 - dSize;
      if (delta == 4) {
        for (int i = 0; i < length; i++,off+=4) {
          int val = (int)(((int)array[offset++]) & valMask);
          packInt(buf, off, (int)(val << shift));
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          int val = (int)(((int)array[offset++]) & valMask);
          packInt(buf, off, (int)(val << shift));
          off += 4;
          for (int j = 4; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for signed int data.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void unpackInt24s (byte[] buf, int off, byte[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // byte offset delta
    if (sign) {
      if (dSize == 24) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (byte)unpackInt24(buf, off);
        }
      }
      else {
        int shift  = 24 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (byte)(unpackInt24(buf, off) >> shift);
        }
      }
    }
    else {
      if (dSize == 24) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (byte)(unpackInt24(buf, off) & 0xFFFFFF);
        }
      }
      else {
        int shift  = 24 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (byte)((unpackInt24(buf, off) & 0xFFFFFF) >>> shift);
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast pack method for unsigned int data.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void packInt24s (byte[] buf, int off, byte[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = (align)? ((fSize <= 32)? 4 : 8) : (fSize/8); // byte offset delta
    int valMask = (sign)? ((int)-1) : ((int)0xFFL); // Bit mask for input value (controls sign-extend)
    if (dSize == 24) {
      if (delta == 3) {
        for (int i = 0; i < length; i++,off+=3) {
          int val = (int)(((int)array[offset++]) & valMask);
          packInt24(buf, off, val);
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          int val = (int)(((int)array[offset++]) & valMask);
          packInt24(buf, off, val);
          off += 3;
          for (int j = 3; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
    else {
      int shift = 24 - dSize;
      if (delta == 3) {
        for (int i = 0; i < length; i++,off+=3) {
          int val = (int)(((int)array[offset++]) & valMask);
          packInt24(buf, off, (int)(val << shift));
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          int val = (int)(((int)array[offset++]) & valMask);
          packInt24(buf, off, (int)(val << shift));
          off += 3;
          for (int j = 3; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for signed short data.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void unpackShorts (byte[] buf, int off, byte[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = fSize / 8; // byte offset delta
    if (sign) {
      if (dSize == 16) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (byte)unpackShort(buf, off);
        }
      }
      else {
        int shift  = 16 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (byte)(unpackShort(buf, off) >> shift);
        }
      }
    }
    else {
      if (dSize == 16) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (byte)(unpackShort(buf, off) & 0xFFFF);
        }
      }
      else {
        int shift  = 16 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (byte)((unpackShort(buf, off) & 0xFFFF) >>> shift);
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast pack method for unsigned short data.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void packShorts (byte[] buf, int off, byte[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int delta = fSize / 8; // byte offset delta
    short valMask = (sign)? ((short)-1) : ((short)0xFFL); // Bit mask for input value (controls sign-extend)
    if (dSize == 16) {
      if (delta == 2) {
        for (int i = 0; i < length; i++,off+=2) {
          short val = (short)(((short)array[offset++]) & valMask);
          packShort(buf, off, val);
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          short val = (short)(((short)array[offset++]) & valMask);
          packShort(buf, off, val);
          off += 2;
          for (int j = 2; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
    else {
      int shift = 16 - dSize;
      if (delta == 2) {
        for (int i = 0; i < length; i++,off+=2) {
          short val = (short)(((short)array[offset++]) & valMask);
          packShort(buf, off, (short)(val << shift));
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          short val = (short)(((short)array[offset++]) & valMask);
          packShort(buf, off, (short)(val << shift));
          off += 2;
          for (int j = 2; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for signed Int12 data.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
   *  @param fSize  (IN)  Item packing field size in bits (must be 12)
   *  @param dSize  (IN)  Data item size in bits (must be 12)
   *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackInt12s (byte[] buf, int off, byte[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int skip = (align)? 1 : 0;
    if (sign) {
      for (int i = 0; i < length; i+=2) {
        int a = (int)buf[off++];
        int b = (int)buf[off++];
        int c = (int)buf[off++];
        int x = (a << 4) | ((b >> 4) & 0x000F);
        int y = (b << 8) | ((c     ) & 0x00FF);
        array[offset++] = (byte)((x << 20) >> 20); // sign extend
        array[offset++] = (byte)((y << 20) >> 20); // sign extend
        off += skip; // skip extra byte in processing-efficient mode
      }
    }
    else {
      for (int i = 0; i < length; i+=2) {
        int a = (int)buf[off++];
        int b = (int)buf[off++];
        int c = (int)buf[off++];
        int x = (a << 4) | ((b >> 4) & 0x000F);
        int y = (b << 8) | ((c     ) & 0x00FF);
        array[offset++] = (byte)(x & 0x0FFF); // clear high-order bits
        array[offset++] = (byte)(y & 0x0FFF); // clear high-order bits
        off += skip; // skip extra byte in processing-efficient mode
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast pack method for signed Int12 data.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
   *  @param fSize  (IN)  Item packing field size in bits (must be 12)
   *  @param dSize  (IN)  Data item size in bits (must be 12)
   *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packInt12s (byte[] buf, int off, byte[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    int skip = (align)?  1 : 0;
    int mask = (sign )? -1 : ((int)0xFFL);
    for (int i = 0; i < length; i+=2) {
      int first  = ((int)array[offset++]) & mask;
      int second = ((int)array[offset++]) & mask;
      buf[off++] = (byte)(first >> 4);
      buf[off++] = (byte)((first << 4) | ((second >> 8) & 0x0F));
      buf[off++] = (byte)(second);
      off += skip; // skip extra byte in processing-efficient mode
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for signed byte data.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void unpackBytes (byte[] buf, int off, byte[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    if ((fSize == 8) && (dSize == 8)) {
      // Fast array copy
      System.arraycopy(buf, off, array, offset, length);
      return;
    }
    int delta = fSize / 8; // byte offset delta
    if (sign) {
      if (dSize == 8) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (byte)unpackByte(buf, off);
        }
      }
      else {
        int shift  = 8 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (byte)(unpackByte(buf, off) >> shift);
        }
      }
    }
    else {
      if (dSize == 8) {
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (byte)(unpackByte(buf, off) & 0xFF);
        }
      }
      else {
        int shift  = 8 - dSize;
        for (int i = 0; i < length; i++,off+=delta) {
          array[offset++] = (byte)((unpackByte(buf, off) & 0xFF) >>> shift);
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast pack method for unsigned byte data.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits (must be multiple of 8)
   *  @param dSize  (IN)  Data item size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static  void packBytes (byte[] buf, int off, byte[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    if ((fSize == 8) && (dSize == 8)) {
      // Fast array copy
      System.arraycopy(array, offset, buf, off, length);
      return;
    }
    int delta = fSize / 8; // byte offset delta
    byte valMask = (sign)? ((byte)-1) : ((byte)0xFFL); // Bit mask for input value (controls sign-extend)
    if (dSize == 8) {
      if (delta == 1) {
        for (int i = 0; i < length; i++,off+=1) {
          byte val = (byte)(((byte)array[offset++]) & valMask);
          packByte(buf, off, val);
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          byte val = (byte)(((byte)array[offset++]) & valMask);
          packByte(buf, off, val);
          off += 1;
          for (int j = 1; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
    else {
      int shift = 8 - dSize;
      if (delta == 1) {
        for (int i = 0; i < length; i++,off+=1) {
          byte val = (byte)(((byte)array[offset++]) & valMask);
          packByte(buf, off, (byte)(val << shift));
        }
      }
      else {
        for (int i = 0; i < length; i++) {
          byte val = (byte)(((byte)array[offset++]) & valMask);
          packByte(buf, off, (byte)(val << shift));
          off += 1;
          for (int j = 1; j < delta; j++) {
            buf[off++] = 0; // set unused bits to zero
          }
        }
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for signed Int4 (nibble) data.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
   *  @param fSize  (IN)  Item packing field size in bits (must be 4)
   *  @param dSize  (IN)  Data item size in bits (must be 4)
   *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackNibbles (byte[] buf, int off, byte[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    if (sign) {
      for (int i = 0; i < length; i+=2) {
        int b = (int)buf[off++];
        array[offset++] = (byte)((b << 24) >> 28); // shift & sign extend
        array[offset++] = (byte)((b << 28) >> 28); // shift & sign extend
      }
    }
    else {
      for (int i = 0; i < length; i+=2) {
        int b = (int)buf[off++];
        array[offset++] = (byte)((b >> 4) & 0xF);
        array[offset++] = (byte)((b     ) & 0xF);
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast pack method for signed Int4 (nibble) data.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert (must be a multiple of 2)
   *  @param fSize  (IN)  Item packing field size in bits (must be 4)
   *  @param dSize  (IN)  Data item size in bits (must be 4)
   *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packNibbles (byte[] buf, int off, byte[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    // Pack function for signed and are identical for nibble data, hence
    // 'sign' is unused here, but included in function definition for consistency.
    for (int i = 0; i < length; i+=2) {
      int first  = (int)array[offset++];
      int second = (int)array[offset++];
      buf[off++] = (byte)((first << 4) | (second & 0xF));
    }
  }
  /** <b>Internal Use Only:</b> Fast unpack method for bit data. Each bit in the
   *  input buffer will be checked, a 0 bit will correspond to the value 0 and a
   *  1 bit will correspond to the value 1.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (OUT) Output array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert (must be a multiple of 8)
   *  @param fSize  (IN)  Item packing field size in bits (must be 1)
   *  @param dSize  (IN)  Data item size in bits (must be 1)
   *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackBits (byte[] buf, int off, byte[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    if (sign) {
      // This uses sign-extending principles to get each bit as 0 or -1 which reflects
      // the fact that 0/-1 and not 0/+1 are the available values in a one-bit use of
      // twos-complement.
      for (int i = 0; i < length; i+=8) {
        int b = (int)buf[off++];
        array[offset++] = (byte)((b << 24) >> 31);
        array[offset++] = (byte)((b << 25) >> 31);
        array[offset++] = (byte)((b << 26) >> 31);
        array[offset++] = (byte)((b << 27) >> 31);
        array[offset++] = (byte)((b << 28) >> 31);
        array[offset++] = (byte)((b << 29) >> 31);
        array[offset++] = (byte)((b << 30) >> 31);
        array[offset++] = (byte)((b << 31) >> 31);
      }
    }
    else {
      for (int i = 0; i < length; i+=8) {
        int b = (int)buf[off++];
        array[offset++] = (byte)((b >> 7) & 0x1);
        array[offset++] = (byte)((b >> 6) & 0x1);
        array[offset++] = (byte)((b >> 5) & 0x1);
        array[offset++] = (byte)((b >> 4) & 0x1);
        array[offset++] = (byte)((b >> 3) & 0x1);
        array[offset++] = (byte)((b >> 2) & 0x1);
        array[offset++] = (byte)((b >> 1) & 0x1);
        array[offset++] = (byte)((b     ) & 0x1);
      }
    }
  }
  /** <b>Internal Use Only:</b> Fast pack method for bit data. Each value in the
   *  input array will be checked, a zero value will correspond to the bit 0 and
   *  any non-zero value will correspond to the bit 1.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input array
   *  @param offset (IN)  Offset into array
   *  @param length (IN)  Number of elements to convert (must be a multiple of 8)
   *  @param fSize  (IN)  Item packing field size in bits (must be 1)
   *  @param dSize  (IN)  Data item size in bits (must be 1)
   *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packBits (byte[] buf, int off, byte[] array, int offset, int length, int fSize, int dSize, boolean align, boolean sign) {
    // Pack function for signed and are identical for bit data, hence
    // 'sign' is unused here, but included in function definition for consistency.
    for (int i = 0; i < length; i+=8) {
      int b = 0;
      b |= (((int)array[offset++]) << 7) & 0x80;
      b |= (((int)array[offset++]) << 6) & 0x40;
      b |= (((int)array[offset++]) << 5) & 0x20;
      b |= (((int)array[offset++]) << 4) & 0x10;
      b |= (((int)array[offset++]) << 3) & 0x08;
      b |= (((int)array[offset++]) << 2) & 0x04;
      b |= (((int)array[offset++]) << 1) & 0x02;
      b |= (((int)array[offset++])     ) & 0x01;
      buf[off++] = (byte)b;
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array, where the data is
   *  aligned to 32-bit word boundaries.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array  (OUT) Output value array (not null)
   *  @param chan   (OUT) Output channel tag array (null if n/a)
   *  @param evt    (OUT) Output event tag array (null if n/a)
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits
   *  @param dSize  (IN)  Data item size in bits
   *  @param eSize  (IN)  Event tag size in bits
   *  @param cSize  (IN)  Channel tag size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackIntWord32 (byte[] buf, int off, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+- - - - - +
    //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
    //   +-----------+--------+-----------+-------------+- - - - - +
    //       dSize      uSize     eSize       cSize        pSize
    //   |------------------ fSize ---------------------|
    //   |---------------------- Word Size ------------------------|
    int    pSize    = 32 - fSize;
    int    evtMask  = ~(((int)-1) << eSize);
    int    chanMask = ~(((int)-1) << cSize);
    int valMask  = (sign)? ((int)-1) : (~(((int)-1) << dSize));
    for (int i = 0; i < length; i++,off+=4) {
      int value = unpackInt(buf, off);
      array[i] = (byte)((value >> (32-dSize)) & valMask);
      if (chan != null) chan[i] = (value >> (pSize      )) & chanMask;
      if (evt  != null) evt[i]  = (value >> (pSize+cSize)) & evtMask;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array, where the data is
   *  aligned to 32-bit word boundaries.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input value array
   *  @param chan   (IN)  Input channel tag array (null if n/a)
   *  @param evt    (IN)  Input event tag array (null if n/a)
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits
   *  @param dSize  (IN)  Data item size in bits
   *  @param eSize  (IN)  Event tag size in bits
   *  @param cSize  (IN)  Channel tag size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packIntWord32 (byte[] buf, int off, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+- - - - - +
    //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
    //   +-----------+--------+-----------+-------------+- - - - - +
    //       dSize      uSize     eSize       cSize        pSize
    //   |------------------ fSize ---------------------|
    //   |---------------------- Word Size ------------------------|
    int    pSize    = 32 - fSize;
    int    evtMask  = ~(((int)-1) << eSize);
    int    chanMask = ~(((int)-1) << cSize);
    int valMask  = (sign)? ((int)-1) : ((int)0xFFL);
    for (int i = 0; i < length; i++,off+=4) {
      int val   = (int)(((int)array[i]) & valMask);
      int value = val << (32-dSize);
      if (chan != null) value |= (chan[i] & chanMask) << (pSize);
      if (evt  != null) value |= (evt[i]  & evtMask ) << (pSize+cSize);
      packInt(buf, off, value);
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array, where the data is
   *  aligned to 64-bit word boundaries.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array  (OUT) Output value array (not null)
   *  @param chan   (OUT) Output channel tag array (null if n/a)
   *  @param evt    (OUT) Output event tag array (null if n/a)
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits
   *  @param dSize  (IN)  Data item size in bits
   *  @param eSize  (IN)  Event tag size in bits
   *  @param cSize  (IN)  Channel tag size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackIntWord64 (byte[] buf, int off, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+- - - - - +
    //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
    //   +-----------+--------+-----------+-------------+- - - - - +
    //       dSize      uSize     eSize       cSize        pSize
    //   |------------------ fSize ---------------------|
    //   |---------------------- Word Size ------------------------|
    int    pSize    = 64 - fSize;
    int    evtMask  = ~(((int)-1) << eSize);
    int    chanMask = ~(((int)-1) << cSize);
    long valMask  = (sign)? ((long)-1) : (~(((long)-1) << dSize));
    if (dSize == 32) {
      // When using Int32/UInt32 the first 32-bits will always the the Int32/UInt32
      // value, so use 32-bit operations to improve performance
      for (int i = 0; i < length; i++,off+=8) {
        int val   = unpackInt(buf, off);
        int value = unpackInt(buf, off+4);
        array[i] = (byte)(val & valMask);
        if (chan != null) chan[i] = ((int)(value >> (pSize      ))) & chanMask;
        if (evt  != null) evt[i]  = ((int)(value >> (pSize+cSize))) & evtMask;
      }
    }
    else {
      for (int i = 0; i < length; i++,off+=8) {
        long value = unpackLong(buf, off);
        array[i] = (byte)((value >> (64-dSize)) & valMask);
        if (chan != null) chan[i] = ((int)(value >> (pSize      ))) & chanMask;
        if (evt  != null) evt[i]  = ((int)(value >> (pSize+cSize))) & evtMask;
      }
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array, where the data is
   *  aligned to 64-bit word boundaries.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input value array
   *  @param chan   (IN)  Input channel tag array (null if n/a)
   *  @param evt    (IN)  Input event tag array (null if n/a)
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits
   *  @param dSize  (IN)  Data item size in bits
   *  @param eSize  (IN)  Event tag size in bits
   *  @param cSize  (IN)  Channel tag size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packIntWord64 (byte[] buf, int off, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+- - - - - +
    //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
    //   +-----------+--------+-----------+-------------+- - - - - +
    //       dSize      uSize     eSize       cSize        pSize
    //   |------------------ fSize ---------------------|
    //   |---------------------- Word Size ------------------------|
    int    pSize    = 64 - fSize;
    int    evtMask  = ~(((int)-1) << eSize);
    int    chanMask = ~(((int)-1) << cSize);
    long valMask  = (sign)? ((long)-1) : ((long)0xFFL);
    if (dSize == 32) {
      // When using Int32/UInt32 the first 32-bits will always the the Int32/UInt32
      // value, so use 32-bit operations to improve performance
      for (int i = 0; i < length; i++,off+=8) {
        int val   = (int)(((long)array[i]) & valMask);
        int value = 0;
        if (chan != null) value  = (chan[i] & chanMask) << (pSize);
        if (evt  != null) value |= (evt[i]  & evtMask ) << (pSize+cSize);
        packInt(buf, off,   val);
        packInt(buf, off+4, value);
      }
    }
    else {
      for (int i = 0; i < length; i++,off+=8) {
        long val   = (long)(((long)array[i]) & valMask);
        long value = val << (64-dSize);
        if (chan != null) value |= ((long)(chan[i] & chanMask)) << (pSize);
        if (evt  != null) value |= ((long)(evt[i]  & evtMask )) << (pSize+cSize);
        packLong(buf, off, value);
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array, where the data is
   *  aligned to 64-bit word boundaries.
   *  @param buf    (IN)  Packet payload buffer
   *  @param off    (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array  (OUT) Output value array (not null)
   *  @param chan   (OUT) Output channel tag array (null if n/a)
   *  @param evt    (OUT) Output event tag array (null if n/a)
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits
   *  @param dSize  (IN)  Data item size in bits
   *  @param eSize  (IN)  Event tag size in bits
   *  @param cSize  (IN)  Channel tag size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackFloatWord64 (byte[] buf, int off, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+- - - - - +
    //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
    //   +-----------+--------+-----------+-------------+- - - - - +
    //       dSize      uSize     eSize       cSize        pSize
    //   |------------------ fSize ---------------------|
    //   |---------------------- Word Size ------------------------|
    int    pSize    = 64 - fSize;
    int    evtMask  = ~(((int)-1) << eSize);
    int    chanMask = ~(((int)-1) << cSize);
    // When using Float32 the first 32-bits will always the the Float32 value, so
    // use 32-bit operations to improve performance
    for (int i = 0; i < length; i++,off+=8) {
      array[i] = (byte)unpackFloat(buf, off);
      int value = unpackInt(buf, off+4);
      if (chan != null) chan[i] = (value >> (pSize      )) & chanMask;
      if (evt  != null) evt[i]  = (value >> (pSize+cSize)) & evtMask;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array, where the data is
   *  aligned to 64-bit word boundaries.
   *  @param buf    (I/O) Packet payload buffer
   *  @param off    (IN)  Offset into buf
   *  @param array  (IN)  Input value array
   *  @param chan   (IN)  Input channel tag array (null if n/a)
   *  @param evt    (IN)  Input event tag array (null if n/a)
   *  @param length (IN)  Number of elements to convert
   *  @param fSize  (IN)  Item packing field size in bits
   *  @param dSize  (IN)  Data item size in bits
   *  @param eSize  (IN)  Event tag size in bits
   *  @param cSize  (IN)  Channel tag size in bits
   *  @param align  (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign   (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packFloatWord64 (byte[] buf, int off, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+- - - - - +
    //   | Data Item | Unused | Event Tag | Channel Tag | Pad Bits |
    //   +-----------+--------+-----------+-------------+- - - - - +
    //       dSize      uSize     eSize       cSize        pSize
    //   |------------------ fSize ---------------------|
    //   |---------------------- Word Size ------------------------|
    int    pSize    = 64 - fSize;
    int    evtMask  = ~(((int)-1) << eSize);
    int    chanMask = ~(((int)-1) << cSize);
    // When using Float32 the first 32-bits will always the the Float32 value, so
    // use 32-bit operations to improve performance
    for (int i = 0; i < length; i++,off+=8) {
      float val   = (float)array[i];
      int   value = 0;
      if (chan != null) value  = (chan[i] & chanMask) << (pSize);
      if (evt  != null) value |= (evt[i]  & evtMask ) << (pSize+cSize);
      packFloat(buf, off,   val);
      packInt(  buf, off+4, value);
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackIntBuffer32 (byte[] buf, int bitOffset, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_dSize  = 32 - dSize;    // pre-compute "32 - dSize" for efficiency
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        if (sign) {
          // sign extend
          array[offset] = (byte)((value << _bits_dSize) >>  _bits_dSize);
        }
        else {
          // leave top bits (which default to 0) as 0
          array[offset] = (byte)value;
        }
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packIntBuffer32 (byte[] buf, int bitOffset, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    int valMask      = (sign)? ((int)-1) : ((int)0xFFL); // Bit mask for input value (controls sign-extend)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        int arrayValue = ((int)array[offset]) & valMask;
        int value      = (int)((arrayValue) << (32 - dSize));
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackIntBuffer64 (byte[] buf, int bitOffset, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_dSize  = 64 - dSize;    // pre-compute "64 - dSize" for efficiency
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        if (sign) {
          // sign extend
          array[offset] = (byte)((value << _bits_dSize) >>  _bits_dSize);
        }
        else {
          // leave top bits (which default to 0) as 0
          array[offset] = (byte)value;
        }
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packIntBuffer64 (byte[] buf, int bitOffset, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    long valMask      = (sign)? ((long)-1) : ((long)0xFFL); // Bit mask for input value (controls sign-extend)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        long arrayValue = ((long)array[offset]) & valMask;
        long value      = (long)((arrayValue) << (64 - dSize));
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackFloatBuffer64 (byte[] buf, int bitOffset, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (byte)intBitsToFloat((int)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packFloatBuffer64 (byte[] buf, int bitOffset, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        float  arrayValue = (float)array[offset];
        long   value      = ((long)floatToRawIntBits(arrayValue)) << 32;
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT1Buffer32 (byte[] buf, int bitOffset, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (byte)fromVRTFloat(DataItemFormat.SignedVRT1, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT1Buffer32 (byte[] buf, int bitOffset, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.SignedVRT1, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT1Buffer64 (byte[] buf, int bitOffset, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (byte)fromVRTFloat(DataItemFormat.SignedVRT1, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT1Buffer64 (byte[] buf, int bitOffset, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.SignedVRT1, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT2Buffer32 (byte[] buf, int bitOffset, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (byte)fromVRTFloat(DataItemFormat.SignedVRT2, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT2Buffer32 (byte[] buf, int bitOffset, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.SignedVRT2, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT2Buffer64 (byte[] buf, int bitOffset, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (byte)fromVRTFloat(DataItemFormat.SignedVRT2, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT2Buffer64 (byte[] buf, int bitOffset, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.SignedVRT2, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT3Buffer32 (byte[] buf, int bitOffset, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (byte)fromVRTFloat(DataItemFormat.SignedVRT3, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT3Buffer32 (byte[] buf, int bitOffset, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.SignedVRT3, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT3Buffer64 (byte[] buf, int bitOffset, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (byte)fromVRTFloat(DataItemFormat.SignedVRT3, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT3Buffer64 (byte[] buf, int bitOffset, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.SignedVRT3, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT4Buffer32 (byte[] buf, int bitOffset, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (byte)fromVRTFloat(DataItemFormat.SignedVRT4, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT4Buffer32 (byte[] buf, int bitOffset, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.SignedVRT4, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT4Buffer64 (byte[] buf, int bitOffset, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (byte)fromVRTFloat(DataItemFormat.SignedVRT4, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT4Buffer64 (byte[] buf, int bitOffset, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.SignedVRT4, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT5Buffer32 (byte[] buf, int bitOffset, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (byte)fromVRTFloat(DataItemFormat.SignedVRT5, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT5Buffer32 (byte[] buf, int bitOffset, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.SignedVRT5, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT5Buffer64 (byte[] buf, int bitOffset, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (byte)fromVRTFloat(DataItemFormat.SignedVRT5, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT5Buffer64 (byte[] buf, int bitOffset, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.SignedVRT5, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT6Buffer32 (byte[] buf, int bitOffset, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (byte)fromVRTFloat(DataItemFormat.SignedVRT6, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT6Buffer32 (byte[] buf, int bitOffset, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.SignedVRT6, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackSignedVRT6Buffer64 (byte[] buf, int bitOffset, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (byte)fromVRTFloat(DataItemFormat.SignedVRT6, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packSignedVRT6Buffer64 (byte[] buf, int bitOffset, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.SignedVRT6, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT1Buffer32 (byte[] buf, int bitOffset, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (byte)fromVRTFloat(DataItemFormat.UnsignedVRT1, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT1Buffer32 (byte[] buf, int bitOffset, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.UnsignedVRT1, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT1Buffer64 (byte[] buf, int bitOffset, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (byte)fromVRTFloat(DataItemFormat.UnsignedVRT1, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT1Buffer64 (byte[] buf, int bitOffset, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.UnsignedVRT1, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT2Buffer32 (byte[] buf, int bitOffset, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (byte)fromVRTFloat(DataItemFormat.UnsignedVRT2, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT2Buffer32 (byte[] buf, int bitOffset, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.UnsignedVRT2, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT2Buffer64 (byte[] buf, int bitOffset, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (byte)fromVRTFloat(DataItemFormat.UnsignedVRT2, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT2Buffer64 (byte[] buf, int bitOffset, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.UnsignedVRT2, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT3Buffer32 (byte[] buf, int bitOffset, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (byte)fromVRTFloat(DataItemFormat.UnsignedVRT3, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT3Buffer32 (byte[] buf, int bitOffset, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.UnsignedVRT3, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT3Buffer64 (byte[] buf, int bitOffset, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (byte)fromVRTFloat(DataItemFormat.UnsignedVRT3, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT3Buffer64 (byte[] buf, int bitOffset, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.UnsignedVRT3, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT4Buffer32 (byte[] buf, int bitOffset, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (byte)fromVRTFloat(DataItemFormat.UnsignedVRT4, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT4Buffer32 (byte[] buf, int bitOffset, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.UnsignedVRT4, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT4Buffer64 (byte[] buf, int bitOffset, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (byte)fromVRTFloat(DataItemFormat.UnsignedVRT4, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT4Buffer64 (byte[] buf, int bitOffset, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.UnsignedVRT4, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT5Buffer32 (byte[] buf, int bitOffset, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (byte)fromVRTFloat(DataItemFormat.UnsignedVRT5, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT5Buffer32 (byte[] buf, int bitOffset, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.UnsignedVRT5, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT5Buffer64 (byte[] buf, int bitOffset, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (byte)fromVRTFloat(DataItemFormat.UnsignedVRT5, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT5Buffer64 (byte[] buf, int bitOffset, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.UnsignedVRT5, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 32 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT6Buffer32 (byte[] buf, int bitOffset, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int allBitsSet   = (int)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        int value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          int mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (byte)fromVRTFloat(DataItemFormat.UnsignedVRT6, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 32-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT6Buffer32 (byte[] buf, int bitOffset, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 32 - fSize;    // pre-compute "32 - fSize" for efficiency
    int    bitmask      = 32 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        int value      = (int)toVRTFloat(DataItemFormat.UnsignedVRT6, dSize, arrayValue) << (32 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 32 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 32)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Gets the data into an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Unpack 15-bit value mid-buffer:
   *       buffer    = [ xxxx xx11 | 1111 1111 | 1111 1xxx ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1a. Pull in the bits from each byte setting them in the accumulator.
   *           Initial:
   *             value    = [ oooo oooo | oooo oooo ]      (o = Bit defaulted to 0)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             value    = [ oooo oooo | oooo oo11 ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             value    = [ oooo oo11 | 1111 1111 ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             value    = [ o111 1111 | 1111 1111 ]
   *             needBits = 0
   *
   *     1b. Clear top bits/sign extend for integers (float would fill value field)
   *         and then set value in output array.
   *             array[n] = [ 1111 1111 | 1111 1111 ]  signed
   *             array[n] = [ 0111 1111 | 1111 1111 ]  unsigned
   *
   *     2.  Skip over the unused bits
   *
   *     3.  Extract the event tag if present and evt is not null, otherwise skip
   *         over the event tag field.
   *
   *     4.  Extract the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field.
   *  </pre>
   *  @param buf       (IN)  Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf (must be multiple of 64 bits)
   *  @param array     (OUT) Output value array (not null)
   *  @param chan      (OUT) Output channel tag array (null if n/a)
   *  @param evt       (OUT) Output event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or link efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void unpackUnsignedVRT6Buffer64 (byte[] buf, int bitOffset, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    long allBitsSet   = (long)(-1);          // Mask value with all bits set
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        // Not enough bits remaining in this word, move to next word (skipping pad bits)
        bitOffset = (bitOffset + 32) & bitmaskInv;
      }
      // ==== Step 1 =============================================================
      if (true) {
        long value    = 0; // Bit accumulator
        int    needBits = dSize; // bits remaining to get
        while (needBits > 0) {
          int    avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int    numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte   octet   = buf[bitOffset>>3];
          long mask    = ~(allBitsSet << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        array[offset] = (byte)fromVRTFloat(DataItemFormat.UnsignedVRT6, dSize, (long)value);
      }
      // ==== Step 2 =============================================================
      bitOffset += uSize;
      // ==== Step 3 =============================================================
      if (evt != null) {
        int value    = 0;
        int needBits = eSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        evt[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += eSize;
      }
      // ==== Step 4 =============================================================
      if (chan != null) {
        int value    = 0;
        int needBits = cSize; // bits remaining to get
        while (needBits > 0) {
          int  avail   = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte octet   = buf[bitOffset>>3];
          int  mask    = ~(((int)-1) << numBits);              // mask (e.g. numBits=3 -> mask=0x07);
          value      = (value << numBits) | ((octet >> (avail - numBits)) & mask);
          needBits  -= numBits;
          bitOffset += numBits;
        }
        chan[offset] = value; // leave top bits (which default to 0) as 0
      }
      else {
        bitOffset += cSize;
      }
      // ==== Done ===============================================================
      offset++;
    }
  }
  /** <b>Internal Use Only:</b> Sets the data from an array. <br>
   *  <br>
   *  Algorithm example:
   *  <pre>
   *     Pack 15-bit value mid-buffer:
   *       value     = [ s111 1111 | 1111 1111 ]   (s = sign extend or 0)
   *       buffer    = [ xxxx xxyy | yyyy yyyy | yyyy yzzz ]
   *       bitOffset = N*8 + 6;
   *
   *     0.  If using processing-efficient mode to prevent crossing word boundaries
   *         (align) and there are not enough bits available, skip the remaining
   *         bits and start at the next word.
   *
   *     1.  Cast incoming value to match 64-bit container and then push
   *         bits from the given value and set them in the octets.
   *           Initial:
   *             buffer   = [ xxxx xxYY | YYYY YYYY | YYYY Yzzz ]  (x,z = Bits to keep)
   *             needBits = 15
   *
   *           Pass #1:
   *             avail    = 2
   *             numBits  = 2
   *             buffer   = [ xxxx xx11 | YYYY YYYY | YYYY Yzzz ]
   *             needBits = 13
   *
   *           Pass #2:
   *             avail    = 8
   *             numBits  = 8
   *             buffer   = [ xxxx xx11 | 1111 1111 | YYYY Yzzz ]
   *             needBits = 5
   *
   *           Pass #3:
   *             avail    = 8
   *             numBits  = 5  (only need 5 more)
   *             buffer   = [ xxxx xx11 | 1111 1111 | 1111 1zzz ]
   *             needBits = 0
   *
   *     2.  Set the unused bits to 0.
   *
   *     3.  Insert the event tag if present and evt is not null, otherwise skip
   *         over the event tag field. If the event tag is present, but evt is
   *         null, set the event tag to 0.
   *
   *     4.  Insert the channel tag if present and chan is not null, otherwise
   *         skip over the channel tag field. If the channel tag is present, but
   *         chan is null, set the channel tag to 0.
   *  </pre>
   *  @param buf       (I/O) Packet payload buffer
   *  @param bitOffset (IN)  Bit offset into buf
   *  @param array     (IN)  Input value array
   *  @param chan      (IN)  Input channel tag array (null if n/a)
   *  @param evt       (IN)  Input event tag array (null if n/a)
   *  @param length    (IN)  Number of elements to convert
   *  @param fSize     (IN)  Item packing field size in bits
   *  @param dSize     (IN)  Data item size in bits
   *  @param eSize     (IN)  Event tag size in bits
   *  @param cSize     (IN)  Channel tag size in bits
   *  @param align     (IN)  Is processing efficient mode used (true) or packing efficient (false)?
   *  @param sign      (IN)  Is value signed (true) or unsigned (false)?
   */
  @SuppressWarnings("cast")
  private static void packUnsignedVRT6Buffer64 (byte[] buf, int bitOffset, byte[] array, int[] chan, int[] evt, int length, int fSize, int dSize, int eSize, int cSize, boolean align, boolean sign) {
    // Item Packing Field
    //   +-----------+--------+-----------+-------------+
    //   | Data Item | Unused | Event Tag | Channel Tag |
    //   +-----------+--------+-----------+-------------+
    //       dSize      uSize     eSize       cSize
    //   |------------------ fSize ---------------------|
    int    uSize        = fSize - dSize - eSize - cSize;
    int    offset       = 0;
    int    _bits_fSize  = 64 - fSize;    // pre-compute "64 - fSize" for efficiency
    int    bitmask      = 64 - 1;        // Bit mask for container (e.g. 0x0000001F for 32)
    int    bitmaskInv   = ~bitmask;              // Bit mask for container (e.g. 0xFFFFFFE0 for 32)
    if ((evt == null) || (eSize == 0)) {
      // Treat event tag as unused since we have nothing to insert there (this
      // will be slightly faster in the loop below).
      uSize = uSize + eSize;
      eSize = 0;
      if (chan == null) {
        // Treat channel tag as unused since we have nothing to insert there (this
        // will be slightly faster in the loop below).
        uSize = uSize + cSize;
        cSize = 0;
      }
    }
    for (int i = 0; i < length; i++) {
      // ==== Step 0 =============================================================
      if (align && ((bitOffset & bitmask) > _bits_fSize)) {
        if (true) { //TODO: make this optional
          // Not enough bits remaining in this word, move to next word (clearing pad bits)
          int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
          while (needBits > 0) {
            int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
            int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
            byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
            byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
            byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
            int old = (int)buf[bitOffset>>3];
            buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
            needBits  -= numBits;
            bitOffset += numBits;
          }
        }
        else {
          // Not enough bits remaining in this word, move to next word (skipping pad bits)
          bitOffset = (bitOffset + 32) & bitmaskInv;
        }
      }
      // ==== Step 1 =============================================================
      if (true) {
        double arrayValue = (double)array[offset];
        long value      = (long)toVRTFloat(DataItemFormat.UnsignedVRT6, dSize, arrayValue) << (64 - dSize);
        int    needBits   = dSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          long old = (long)buf[bitOffset>>3];
          long val = value >> (64 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 2 =============================================================
      if (uSize > 0) {
        int needBits = uSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
          needBits  -= numBits;
          bitOffset += numBits;
        }
      }
      // ==== Step 3 =============================================================
      if (eSize > 0) {
        int value    = evt[offset] << (32 - eSize);
        int needBits = eSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Step 4 =============================================================
      if (cSize > 0) {
        int value    = chan[offset] << (32 - cSize);
        int needBits = cSize; // bits remaining to set
        while (needBits > 0) {
          int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
          int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
          byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
          byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
          byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
          int old = (int)buf[bitOffset>>3];
          int val = value >> (32 - avail);
          buf[bitOffset>>3] = (byte)((old & keepMask) | (val & ~keepMask));
          needBits  -= numBits;
          bitOffset += numBits;
          value      = value << numBits;
        }
      }
      // ==== Done ===============================================================
      offset++;
    }
    // ==== End of Packet Pad Bits =============================================
    if (true) { //TODO: make this optional
      // Clear out any bits remaining in the current word that would be at the end
      // of the packet, this applies to both link and processing efficient.
      int needBits = 64 - (bitOffset & bitmask); // bits remaining to set
      while ((needBits > 0) && (needBits < 64)) {
        int  avail    = 8 - (bitOffset & 0x7);                 // bits available in current octet
        int  numBits  = (avail <= needBits)? avail : needBits; // bits to read from current octet
        byte keepHi   = (byte)(0xFF << avail);                 // High-order bits to keep
        byte keepLo   = (byte)(~(0xFF << (avail - numBits)));  // Low-order  bits to keep
        byte keepMask = (byte)(keepHi | keepLo);               // Bits to keep
        int old = (int)buf[bitOffset>>3];
        buf[bitOffset>>3] = (byte)(old & keepMask); // <-- this differs from the others since val is always 0
        needBits  -= numBits;
        bitOffset += numBits;
      }
    }
  }
  /** <b>Internal Use Only:</b> Unpacks values with the given format specifier as
   *  an array of <tt>byte</tt>. <br>
   *  <br>
   *  Setting the channel tags (<tt>chan</tt>) and/or event tags (<tt>evt</tt>)
   *  arrays to null will cause any channel or event tags present to be ignored.
   *  In most cases this results in a performance improvement. <br>
   *  <br>
   *  If the channel tags (<tt>chan</tt>) and/or event tags (<tt>evt</tt>) arrays
   *  are non-null when there are no channel or event tags present, the values in
   *  the arrays will not be modified.
   *  @param pf     (IN)  The data format
   *  @param buf    (IN)  The buffer
   *  @param off    (IN)  The buffer offset
   *  @param array  (OUT) The output array for the values
   *  @param chan   (OUT) The output array for the channel tags (null if n/a)
   *  @param evt    (OUT) The output array for the event tags (null if n/a)
   *  @param length (IN)  Number of elements to convert
   *  @return The output array (same as <tt>array</tt>).
   */
  @SuppressWarnings("fallthrough")
  public static byte[] unpackAsByte (PayloadFormat pf, byte[] buf, int off, byte[] array, int[] chan, int[] evt, int length) {
    if (!pf.isValid()) {
      throw new IllegalArgumentException(pf.getValid());
    }
    int            fSize  = pf.getItemPackingFieldSize();
    int            dSize  = pf.getDataItemSize();
    int            eSize  = pf.getEventTagSize();
    int            cSize  = pf.getChannelTagSize();
    boolean        proc   = pf.isProcessingEfficient();
    boolean        sign   = pf.isSigned();
    DataItemFormat format = pf.getDataItemFormat();
    boolean        noTags;
    if (eSize == 0) evt  = null; // no event tags, ignore any array passed in
    if (cSize == 0) chan = null; // no channel tags, ignore any array passed in
    noTags = (chan == null) && (evt == null);
    if (proc && noTags && (fSize >= 17)) {
      // Use faster "effective field size" when ignoring Event & Channel Tags
      fSize = (fSize <= 32)? 32 : 64;
    }
    switch (format) {
      case SignedInt:   // FALLTHROUGH
      case UnsignedInt:
        // ---- Try fast methods -------------------------------------------------
        if (noTags) {
          switch (fSize) {
            case  8: unpackBytes(  buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
            case 16: unpackShorts( buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
            case 24: unpackInt24s( buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
            case 32: unpackInts(   buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
            case 64: unpackLongs(  buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
          }
        }
        if (fSize == dSize) { // implicit noTags=true in this case
          switch (fSize) {
            case  1: if ((length % 8) == 0) { unpackBits(   buf, off, array, 0, length, fSize, dSize, proc, sign); return array; } break;
            case  4: if ((length % 2) == 0) { unpackNibbles(buf, off, array, 0, length, fSize, dSize, proc, sign); return array; } break;
            case 12: if ((length % 2) == 0) { unpackInt12s( buf, off, array, 0, length, fSize, dSize, proc, sign); return array; } break;
          }
        }
        if ((proc && (fSize >= 17)) || (fSize == 32) || (fSize == 64)) {
          if (fSize <= 32) {
            unpackIntWord32(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
          }
          else {
            unpackIntWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
          }
        }
        // ---- Fall back to slow method -----------------------------------------
        if (fSize <= 32) {
          unpackIntBuffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackIntBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case Float:
        // ---- Try fast methods -------------------------------------------------
        if (fSize == dSize) { // implicit noTags=true in this case
          unpackFloats(buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
        }
        if ((proc && (fSize >= 33)) || (fSize == 64)) {
          unpackFloatWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        // ---- Fall back to slow method -----------------------------------------
        unpackFloatBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
      case Double:
        // ---- Only fast method for double (yea!) -------------------------------
        unpackDoubles(buf, off, array, 0, length, fSize, dSize, proc, sign); return array;
      case SignedVRT1:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackSignedVRT1Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackSignedVRT1Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case SignedVRT2:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackSignedVRT2Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackSignedVRT2Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case SignedVRT3:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackSignedVRT3Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackSignedVRT3Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case SignedVRT4:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackSignedVRT4Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackSignedVRT4Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case SignedVRT5:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackSignedVRT5Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackSignedVRT5Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case SignedVRT6:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackSignedVRT6Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackSignedVRT6Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case UnsignedVRT1:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackUnsignedVRT1Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackUnsignedVRT1Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case UnsignedVRT2:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackUnsignedVRT2Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackUnsignedVRT2Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case UnsignedVRT3:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackUnsignedVRT3Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackUnsignedVRT3Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case UnsignedVRT4:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackUnsignedVRT4Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackUnsignedVRT4Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case UnsignedVRT5:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackUnsignedVRT5Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackUnsignedVRT5Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      case UnsignedVRT6:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          unpackUnsignedVRT6Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
        else {
          unpackUnsignedVRT6Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return array;
        }
      default:
        throw new UnsupportedOperationException("Unpacking of VRT float types not supported yet");
    }
  }
  /** <b>Internal Use Only:</b> Packs values with the given format specifier from
   *  an array of byte. <br>
   *  <br>
   *  Setting the channel tags (<tt>chan</tt>) and/or event tags (<tt>evt</tt>)
   *  arrays to null will cause any channel or event tags present to be set to
   *  zero. In most cases this results in a performance improvement over passing
   *  in an array of zeros. <br>
   *  <br>
   *  If the channel tags (<tt>chan</tt>) and/or event tags (<tt>evt</tt>) arrays
   *  are non-null when there are no channel or event tags present, the values in
   *  the arrays will be ignored.
   *  @param pf     (IN)  The data format
   *  @param buf    (I/O) The buffer
   *  @param off    (IN)  The buffer offset
   *  @param array  (IN)  The values to pack
   *  @param chan   (OUT) The output array for the channel tags (null if n/a)
   *  @param evt    (OUT) The output array for the event tags (null if n/a)
   *  @param length (IN)  Number of elements to convert
   */
  @SuppressWarnings("fallthrough")
  public static void packAsByte (PayloadFormat pf, byte[] buf, int off, byte[] array, int[] chan, int[] evt, int length) {
    if (!pf.isValid()) {
      throw new IllegalArgumentException(pf.getValid());
    }
    int            fSize  = pf.getItemPackingFieldSize();
    int            dSize  = pf.getDataItemSize();
    int            eSize  = pf.getEventTagSize();
    int            cSize  = pf.getChannelTagSize();
    boolean        proc   = pf.isProcessingEfficient();
    boolean        sign   = pf.isSigned();
    DataItemFormat format = pf.getDataItemFormat();
    boolean        noTags;
    if (eSize == 0) evt  = null; // no event tags, ignore any array passed in
    if (cSize == 0) chan = null; // no channel tags, ignore any array passed in
    noTags = (chan == null) && (evt == null);
    if (proc && noTags && (fSize >= 17)) {
      // Use faster "effective field size" when ignoring Event & Channel Tags
      fSize = (fSize <= 32)? 32 : 64;
    }
    switch (format) {
      case SignedInt:   // FALLTHROUGH
      case UnsignedInt:
        // ---- Try fast methods -------------------------------------------------
        if (noTags) {
          switch (fSize) {
            case  8: packBytes(  buf, off, array, 0, length, fSize, dSize, proc, sign); return;
            case 16: packShorts( buf, off, array, 0, length, fSize, dSize, proc, sign); return;
            case 24: packInt24s( buf, off, array, 0, length, fSize, dSize, proc, sign); return;
            case 32: packInts(   buf, off, array, 0, length, fSize, dSize, proc, sign); return;
            case 64: packLongs(  buf, off, array, 0, length, fSize, dSize, proc, sign); return;
          }
        }
        if (fSize == dSize) { // implicit noTags=true in this case
          switch (fSize) {
            case  1: if ((length % 8) == 0) { packBits(   buf, off, array, 0, length, fSize, dSize, proc, sign); return; } break;
            case  4: if ((length % 2) == 0) { packNibbles(buf, off, array, 0, length, fSize, dSize, proc, sign); return; } break;
            case 12: if ((length % 2) == 0) { packInt12s( buf, off, array, 0, length, fSize, dSize, proc, sign); return; } break;
          }
        }
        if ((proc && (fSize >= 17)) || (fSize == 32) || (fSize == 64)) {
          if (fSize <= 32) {
            packIntWord32(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
          }
          else {
            packIntWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
          }
        }
        // ---- Fall back to slow method -----------------------------------------
        if (fSize <= 32) {
          packIntBuffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packIntBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case Float:
        // ---- Try fast methods -------------------------------------------------
        if (fSize == dSize) { // implicit noTags=true in this case
          packFloats(buf, off, array, 0, length, fSize, dSize, proc, sign); return;
        }
        if ((proc && (fSize >= 33)) || (fSize == 64)) {
          packFloatWord64(buf, off, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        // ---- Fall back to slow method -----------------------------------------
        packFloatBuffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
      case Double:
        // ---- Only fast method for double (yea!) -------------------------------
        packDoubles(buf, off, array, 0, length, fSize, dSize, proc, sign); return;
      case SignedVRT1:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packSignedVRT1Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packSignedVRT1Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case SignedVRT2:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packSignedVRT2Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packSignedVRT2Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case SignedVRT3:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packSignedVRT3Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packSignedVRT3Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case SignedVRT4:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packSignedVRT4Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packSignedVRT4Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case SignedVRT5:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packSignedVRT5Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packSignedVRT5Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case SignedVRT6:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packSignedVRT6Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packSignedVRT6Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case UnsignedVRT1:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packUnsignedVRT1Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packUnsignedVRT1Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case UnsignedVRT2:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packUnsignedVRT2Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packUnsignedVRT2Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case UnsignedVRT3:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packUnsignedVRT3Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packUnsignedVRT3Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case UnsignedVRT4:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packUnsignedVRT4Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packUnsignedVRT4Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case UnsignedVRT5:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packUnsignedVRT5Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packUnsignedVRT5Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      case UnsignedVRT6:
        // ---- Only have slow method for now ------------------------------------
        if (fSize <= 32) {
          packUnsignedVRT6Buffer32(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
        else {
          packUnsignedVRT6Buffer64(buf, off*8, array, chan, evt, length, fSize, dSize, eSize, cSize, proc, sign); return;
        }
      default:
        throw new UnsupportedOperationException("Packing of VRT float types not supported yet");
    }
  }
}
